---
title: "设计模式"
date: 2021-09-19T09:37:37+08:00
tags: ['设计模式', 'c++', 'design pattern']
categories: ['c&c++']
draft: true
---

## 设计模式简介

- 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。
- 使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

### 设计模式的设计原则

- 对接口编程而不是对实现编程
- 优先使用对象组合而不是继承

### 设计模式的类型

目前总共有23 种设计模式。这些模式可以分为三大类：
- 创建型模式（Creational Patterns）
- 结构型模式（Structural Patterns）
- 行为型模式（Behavioral Patterns）
- 当然，我们还会讨论另一类设计模式：J2EE 设计模式。

<style>table th:first-of-type{width:390px;}</style>
|模式&描述|包括|
|:----|:----|
|`创建型模式`<br/><br/>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用`new`运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活|工厂模式（Factory Pattern）<br/>抽象工厂模式（Abstract Factory Pattern）<br/>单例模式（Singleton Pattern）<br/>建造者模式（Builder Pattern）<br/>原型模式（Prototype Pattern）|
|`结构型模式`<br/><br/>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式|适配器模式(Adapter Pattern)<br/>桥接模式(Bridge Pattern)<br/>过滤器模式(Filter、Criteria Pattern)<br/>组合模式(Composite Pattern)<br/>装饰器模式(Decorator Pattern)<br/>外观模式(Facade Pattern)<br/>享元模式(Flyweight Pattern)<br/>代理模式(Proxy Pattern)|
|`行为型模式`<br/><br/>这些设计模式特别关注对象之间的通信|责任链模式(Chain of Responsibility Pattern)<br/>命令模式(Command Pattern)<br/>解释器模式(Interpreter Pattern)<br/>迭代器模式(Iterator Pattern)<br/>中介者模式(Mediator Pattern)<br/>备忘录模式(Memento Pattern)<br/>观察者模式(Observer Pattern)<br/>状态模式(State Pattern)<br/>空对象模式(Null Object Pattern)<br/>策略模式(Strategy Pattern)<br/>模板模式(Template Pattern)<br/>访问者模式(Visitor Pattern)<br/>|
|`J2EE 模式`<br/><br/>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的|MVC 模式(MVC Pattern)<br/>业务代表模式(Business Delegate Pattern)<br/>组合实体模式(Composite Entity Pattern)<br/>数据访问对象模式(Data Access Object Pattern)<br/>前端控制器模式(Front Controller Pattern)<br/>拦截过滤器模式(Intercepting Filter Pattern)<br/>服务定位器模式(Service Locator Pattern)<br/>传输对象模式(Transfer Object Pattern)|


<div align=center><img src='/pic/c&c++/dp-0.jpg'/></div>

### 设计模式六大原则
1. 开闭原则: **对扩展开放，对修改关闭**
2. 里氏代换原则: **任何基类可以出现的地方，子类一定可以出现**(LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为，里氏代换原则是对开闭原则的补充)。
3. 依赖倒转原则: **针对接口编程，依赖于抽象而不依赖于具体**(这个原则是开闭原则的基础)
4. 接口隔离原则: **使用多个隔离的接口，比使用单个接口要好**(降低类之间的依赖/耦合度)
5. 迪米特法则，又称最少知道原则: **一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立**
6. 合成复用原则: **尽量使用合成/聚合的方式，而不是使用继承**

## 设计模式

### 工厂模式

> 在工厂模式中，我们在创建对象时**不会对客户端暴露创建逻辑**，并且是**通过使用一个共同的接口来指向新创建的对象**

#### 意图

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行

#### 主要解决
主要解决接口选择的问题

#### 优点

1. 一个调用者想创建一个对象，只要知道其名称就可以了
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以
3. 屏蔽产品的具体实现，调用者只关心产品的接口。

#### 缺点

每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

#### 使用场景

1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方
2. 数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时
3. 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

> 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度

#### 实现

<div align=center><img src='/pic/c&c++/dp-f-0.jpg'/></div>
<center>工厂模式</center>

#### 例子 
1. 创建一个接口 `Shape.java`
```java

public interface Shape {
   void draw();
}
```

2. 创建实现接口的实体类
```java
// Rectangle.java
public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

```java
// Square.java

public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

```java
// Circle.java

public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

3. 创建一个工厂`ShapeFactory.java`

```java

public class ShapeFactory {

   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

5. 使用工厂
```java

public class FactoryPatternDemo {

   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");

      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```

### 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

#### 意图
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

#### 主要解决
主要解决接口选择的问题

#### 何时使用
系统的产品有多于一个的产品族，而系统只消费其中某一族的产品

#### 优点
当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象

#### 缺点
产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码

#### 使用场景
1. QQ 换皮肤，一整套一起换
2. 生成不同操作系统的程序

> 产品族难扩展，产品等级易扩展

#### 实现
<div align=center><img src='/pic/c&c++/dp-af-0.jpg'/></div>
<center>抽象工厂模式</center>

#### 例子
1. 创建一个接口
```java
// Shape.java

public interface Shape {
   void draw();
}
```

2. 创建实现接口的实体类
```java
// Rectangle.java


public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}

```

```java
// Square.java


public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}

```

```java
// Circle.java

public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

3. 创建颜色的接口
```java
// Color.java

public interface Color {
   void fill();
}
```

4. 创建实现接口的实体类

```java
// Red.java

public class Red implements Color {

   @Override
   public void fill() {
      System.out.println("Inside Red::fill() method.");
   }
}
```

```java
// Green.java

public class Green implements Color {

   @Override
   public void fill() {
      System.out.println("Inside Green::fill() method.");
   }
}
```

```java
// Blue.java

public class Blue implements Color {

   @Override
   public void fill() {
      System.out.println("Inside Blue::fill() method.");
   }
}

```

5. 为 Color 和 Shape 对象创建抽象类来获取工厂

```java
// AbstractFactory.java

public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
}
```

6. 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象

```java
// ShapeFactory.java


public class ShapeFactory extends AbstractFactory {

   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }

   @Override
   public Color getColor(String color) {
      return null;
   }
}
```

```java
// ColorFactory.java


public class ColorFactory extends AbstractFactory {

   @Override
   public Shape getShape(String shapeType){
      return null;
   }

   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }
      if(color.equalsIgnoreCase("RED")){
         return new Red();
      } else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
      } else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      return null;
   }
}
```

7. 创建一个工厂创建器/生成器类，通过传递形状颜色信息来获取工厂
```java
// FactoryProducer.java

public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }
      return null;
   }
}
```

8. 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象
```java
// AbstractFactoryPatternDemo.java

public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {

      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");

      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape("CIRCLE");

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape("RECTANGLE");

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape("SQUARE");

      //调用 Square 的 draw 方法
      shape3.draw();

      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");

      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor("RED");

      //调用 Red 的 fill 方法
      color1.fill();

      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor("GREEN");

      //调用 Green 的 fill 方法
      color2.fill();

      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor("BLUE");

      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
```

### 单例模式
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象

#### 意图
保证一个类仅有一个实例，并提供一个访问它的全局访问点

#### 主要解决
一个全局使用的类频繁地创建与销毁

#### 何时使用
当您想控制实例数目，节省系统资源的时候

#### 优点
1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）
2. 避免对资源的多重占用（比如写文件操作）

#### 缺点
没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

#### 使用场景
1. 要求生产唯一序列号
2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来
3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等

#### 实现
<div align=center><img src='/pic/c&c++/dp-s.jpg'/></div>
<center>单例模式</center>

#### 例子
1. 创建一个 Singleton 类

```java
// SingleObject.java


public class SingleObject {

   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();

   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}

   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }

   public void showMessage(){
      System.out.println("Hello World!");
   }
}
```

2. 从 singleton 类获取唯一的对象
```java
// SingletonPatternDemo.java

public class SingletonPatternDemo {
   public static void main(String[] args) {

      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();

      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();

      //显示消息
      object.showMessage();
   }
}
```

#### 单例的几种实现方式
1. 懒汉式，线程不安全
```java

public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

2. 懒汉式，线程安全
```java

public class Singleton {
    private static Singleton instance;
    private Singleton (){}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

3. 饿汉式，线程安全
```java

public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}
    public static Singleton getInstance() {
    return instance;
    }
}
```

### 构造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象

#### 意图

将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示

#### 主要解决
主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定

#### 何时使用
一些基本部件不会变，而其组合经常变化的时候

#### 优点
1. 建造者独立，易扩展
2. 便于控制细节风险

#### 缺点
1. 产品必须有共同点，范围有限制
2. 如内部变化复杂，会有很多的建造类

#### 使用场景
1. 需要生成的对象具有复杂的内部结构
2. 需要生成的对象内部属性本身相互依赖

#### 实现

<div align=center><img src='/pic/c&c++/dp-b.svg'/></div>
<center>构造者模式</center>

#### 例子

1. 创建一个表示食物条目和食物包装的接口
```java
// Item.java

public interface Item {
   public String name();
   public Packing packing();
   public float price();
}
```

```java
// Packing.java

public interface Packing {
   public String pack();
}
```

2. 创建实现 Packing 接口的实体类

```java
// Wrapper.java

public class Wrapper implements Packing {

   @Override
   public String pack() {
      return "Wrapper";
   }
}
```

```java
// Bottle.java

public class Bottle implements Packing {

   @Override
   public String pack() {
      return "Bottle";
   }
}
```

3. 创建实现 Item 接口的抽象类，该类提供了默认的功能
```java
// Burger.java

public abstract class Burger implements Item {

   @Override
   public Packing packing() {
      return new Wrapper();
   }

   @Override
   public abstract float price();
}
```

```java
// ColdDrink.java

public abstract class ColdDrink implements Item {

    @Override
    public Packing packing() {
       return new Bottle();
    }

    @Override
    public abstract float price();
}
```

4. 创建扩展了 Burger 和 ColdDrink 的实体类
```java
// VegBurger.java

public class VegBurger extends Burger {

   @Override
   public float price() {
      return 25.0f;
   }

   @Override
   public String name() {
      return "Veg Burger";
   }
}
```

```java
// ChickenBurger.java

public class ChickenBurger extends Burger {

   @Override
   public float price() {
      return 50.5f;
   }

   @Override
   public String name() {
      return "Chicken Burger";
   }
}
```

```java
// Coke.java

public class Coke extends ColdDrink {

   @Override
   public float price() {
      return 30.0f;
   }

   @Override
   public String name() {
      return "Coke";
   }
}
```

```java
// Pepsi.java

public class Pepsi extends ColdDrink {

   @Override
   public float price() {
      return 35.0f;
   }

   @Override
   public String name() {
      return "Pepsi";
   }
}
```

5. 创建一个 Meal 类，带有上面定义的 Item 对象
```Meal.java

import java.util.ArrayList;
import java.util.List;

public class Meal {
   private List<Item> items = new ArrayList<Item>();

   public void addItem(Item item){
      items.add(item);
   }

   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }
      return cost;
   }

   public void showItems(){
      for (Item item : items) {
         System.out.print("Item : "+item.name());
         System.out.print(", Packing : "+item.packing().pack());
         System.out.println(", Price : "+item.price());
      }
   }
}
```

6. 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象
```java
// MealBuilder.java


public class MealBuilder {

   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }

   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
```

7. BuilderPatternDemo
```java
// BuilderPatternDemo.java

public class BuilderPatternDemo {
   public static void main(String[] args) {
      MealBuilder mealBuilder = new MealBuilder();

      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println("Veg Meal");
      vegMeal.showItems();
      System.out.println("Total Cost: " +vegMeal.getCost());

      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println("\n\nNon-Veg Meal");
      nonVegMeal.showItems();
      System.out.println("Total Cost: " +nonVegMeal.getCost());
   }
}
```

### 原型模式
原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能
<br/>

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

#### 意图
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

#### 主要解决
在运行期建立和删除原型

#### 何时使用
1. 当一个系统应该独立于它的产品创建，构成和表示时
2. 当要实例化的类是在运行时刻指定时，例如，通过动态装载
3. 为了避免创建一个与产品类层次平行的工厂类层次时
4. 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

#### 优点
1. 性能提高
2. 逃避构造函数的约束

#### 缺点
1. 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候
2. 必须实现 Cloneable 接口

#### 使用场景

1. 资源优化场景
2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等
3. 性能和安全要求的场景 
4. 通过`new`产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式
5. 一个对象多个修改者的场景
6. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用
7. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 
> 注意：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流

#### 实现

<div align=center><img src='/pic/c&c++/dp-pt.png'/></div>
<center>原型模式</center>

#### 例子
1. 创建一个实现了 Cloneable 接口的抽象类
```java
// Shape.java


public abstract class Shape implements Cloneable {

   private String id;
   protected String type;

   abstract void draw();

   public String getType(){
      return type;
   }

   public String getId() {
      return id;
   }

   public void setId(String id) {
      this.id = id;
   }

   public Object clone() {
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}
```

2. 创建扩展了上面抽象类的实体类

```java
// Rectangle.java

public class Rectangle extends Shape {

   public Rectangle(){
     type = "Rectangle";
   }

   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

```java
// Square.java


public class Square extends Shape {

   public Square(){
     type = "Square";
   }

   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

```java
// Circle.java

public class Circle extends Shape {

   public Circle(){
     type = "Circle";
   }

   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

3. 创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中
```java
// ShapeCache.java

import java.util.Hashtable;

public class ShapeCache {

   private static Hashtable<String, Shape> shapeMap
      = new Hashtable<String, Shape>();

   public static Shape getShape(String shapeId) {
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone();
   }

   // 对每种形状都运行数据库查询，并创建该形状
   // shapeMap.put(shapeKey, shape);
   // 例如，我们要添加三种形状
   public static void loadCache() {
      Circle circle = new Circle();
      circle.setId("1");
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId("2");
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId("3");
      shapeMap.put(rectangle.getId(),rectangle);
   }
}
```

4. PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆
```java
// PrototypePatternDemo.java

public class PrototypePatternDemo {
   public static void main(String[] args) {
      ShapeCache.loadCache();

      Shape clonedShape = (Shape) ShapeCache.getShape("1");
      System.out.println("Shape : " + clonedShape.getType());

      Shape clonedShape2 = (Shape) ShapeCache.getShape("2");
      System.out.println("Shape : " + clonedShape2.getType());

      Shape clonedShape3 = (Shape) ShapeCache.getShape("3");
      System.out.println("Shape : " + clonedShape3.getType());
   }
}
```

### 适配器模式
适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
<br/>
这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

#### 意图
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### 主要解决
主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

#### 何时使用
1. 系统需要使用现有的类，而此类的接口不符合系统的需要
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口
3. 通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 

#### 优点
1. 可以让任何两个没有关联的类一起运行
2. 提高了类的复用
3. 增加了类的透明度
4. 灵活性好

#### 缺点
1. 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
2. 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 

#### 使用场景
有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式

> 注意：**适配器不是在详细设计时添加的**，而是解决正在服役的项目的问题

#### 实现

<div align=center><img src='/pic/c&c++/dp-adp.png'/></div>
<center>适配器模式</center>

#### 例子

1. 为媒体播放器和更高级的媒体播放器创建接口

```java
// MediaPlayer.java

public interface MediaPlayer {
   public void play(String audioType, String fileName);
}
```

```java
// AdvancedMediaPlayer.java

public interface AdvancedMediaPlayer {
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}
```

2. 创建实现了 AdvancedMediaPlayer 接口的实体类
```java
// VlcPlayer.java

public class VlcPlayer implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      System.out.println("Playing vlc file. Name: "+ fileName);
   }

   @Override
   public void playMp4(String fileName) {
      //什么也不做
   }
}
```

```java
// Mp4Player.java

public class Mp4Player implements AdvancedMediaPlayer{

   @Override
   public void playVlc(String fileName) {
      //什么也不做
   }

   @Override
   public void playMp4(String fileName) {
      System.out.println("Playing mp4 file. Name: "+ fileName);
   }
}
```

3. 创建实现了 MediaPlayer 接口的适配器类
```java
// MediaAdapter.java

public class MediaAdapter implements MediaPlayer {

   AdvancedMediaPlayer advancedMusicPlayer;

   public MediaAdapter(String audioType){
      if(audioType.equalsIgnoreCase("vlc") ){
         advancedMusicPlayer = new VlcPlayer();
      } else if (audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer = new Mp4Player();
      }
   }

   @Override
   public void play(String audioType, String fileName) {
      if(audioType.equalsIgnoreCase("vlc")){
         advancedMusicPlayer.playVlc(fileName);
      }else if(audioType.equalsIgnoreCase("mp4")){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}
```

4. 创建实现了 MediaPlayer 接口的实体类
```java
// AudioPlayer.java


public class AudioPlayer implements MediaPlayer {
   MediaAdapter mediaAdapter;

   @Override
   public void play(String audioType, String fileName) {

      //播放 mp3 音乐文件的内置支持
      if(audioType.equalsIgnoreCase("mp3")){
         System.out.println("Playing mp3 file. Name: "+ fileName);
      }
      //mediaAdapter 提供了播放其他文件格式的支持
      else if(audioType.equalsIgnoreCase("vlc")
         || audioType.equalsIgnoreCase("mp4")){
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      }
      else{
         System.out.println("Invalid media. "+
            audioType + " format not supported");
      }
   }
}
```

5. 使用 AudioPlayer 来播放不同类型的音频格式
```java
// AdapterPatternDemo.java

public class AdapterPatternDemo {
   public static void main(String[] args) {
      AudioPlayer audioPlayer = new AudioPlayer();

      audioPlayer.play("mp3", "beyond the horizon.mp3");
      audioPlayer.play("mp4", "alone.mp4");
      audioPlayer.play("vlc", "far far away.vlc");
      audioPlayer.play("avi", "mind me.avi");
   }
}
```

### 桥接模式

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
<br/>
这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

#### 意图
将抽象部分与实现部分分离，使它们都可以独立的变化

#### 主要解决
在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活

#### 何时使用
实现系统可能有多个角度分类，每一种角度都可能变化

#### 应用实例
墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

#### 优点
1. 抽象和实现的分离
2. 优秀的扩展能力
3. 实现细节对客户透明

#### 缺点
桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程

#### 使用场景
1. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系
2. 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用
3. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 

> 对于两个独立变化的维度，使用桥接模式再适合不过了

#### 实现

<div align=center><img src='/pic/c&c++/dp-bridge.svg'/></div>
<center>桥接模式</center>

#### 例子
1. 创建桥接实现接口

```java
// DrawAPI.java

public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
```

2. 创建实现了 DrawAPI 接口的实体桥接实现类
```java
// RedCircle.java

public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
```

```java
// GreenCircle.java

public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: green, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
```

3. 使用 DrawAPI 接口创建抽象类 Shape
```java
// Shape.java

public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();
}
```

4. 创建实现了 Shape 抽象类的实体类
```java
// Circle.java

public class Circle extends Shape {
   private int x, y, radius;

   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;
      this.y = y;
      this.radius = radius;
   }

   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
```

5. 使用 Shape 和 DrawAPI 类画出不同颜色的圆
```java
// BridgePatternDemo.java

public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());

      redCircle.draw();
      greenCircle.draw();
   }
}
```

### 过滤器模式

过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

#### 实现

<div align=center><img src='/pic/c&c++/dp-filter.svg'/></div>
<center>过滤器模式</center>

#### 例子

1. 创建一个类，在该类上应用标准
```java
// Person.java

public class Person {

   private String name;
   private String gender;
   private String maritalStatus;

   public Person(String name,String gender,String maritalStatus){
      this.name = name;
      this.gender = gender;
      this.maritalStatus = maritalStatus;
   }

   public String getName() {
      return name;
   }
   public String getGender() {
      return gender;
   }
   public String getMaritalStatus() {
      return maritalStatus;
   }
}

```

2. 为标准（Criteria）创建一个接口
```java
// Criteria.java

import java.util.List;

public interface Criteria {
   public List<Person> meetCriteria(List<Person> persons);
}

```

3. 创建实现了 Criteria 接口的实体类
```java
// CriteriaMale.java

import java.util.ArrayList;
import java.util.List;

public class CriteriaMale implements Criteria {

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> malePersons = new ArrayList<Person>();
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase("MALE")){
            malePersons.add(person);
         }
      }
      return malePersons;
   }
}

```

```java
// CriteriaFemale.java

import java.util.ArrayList;
import java.util.List;

public class CriteriaFemale implements Criteria {

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> femalePersons = new ArrayList<Person>();
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase("FEMALE")){
            femalePersons.add(person);
         }
      }
      return femalePersons;
   }
}

```

```java
// CriteriaSingle.java

import java.util.ArrayList;
import java.util.List;

public class CriteriaSingle implements Criteria {

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> singlePersons = new ArrayList<Person>();
      for (Person person : persons) {
         if(person.getMaritalStatus().equalsIgnoreCase("SINGLE")){
            singlePersons.add(person);
         }
      }
      return singlePersons;
   }
}
```

```java
// AndCriteria.java

import java.util.List;

public class AndCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public AndCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria;
   }

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);
      return otherCriteria.meetCriteria(firstCriteriaPersons);
   }
}

```

```java
// OrCriteria.java

import java.util.List;

public class OrCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public OrCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria;
   }

   @Override
   public List<Person> meetCriteria(List<Person> persons) {
      List<Person> firstCriteriaItems = criteria.meetCriteria(persons);
      List<Person> otherCriteriaItems = otherCriteria.meetCriteria(persons);

      for (Person person : otherCriteriaItems) {
         if(!firstCriteriaItems.contains(person)){
           firstCriteriaItems.add(person);
         }
      }
      return firstCriteriaItems;
   }
}

```

4. 使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表
```java
// CriteriaPatternDemo.java

import java.util.ArrayList;
import java.util.List;

public class CriteriaPatternDemo {
   public static void main(String[] args) {
      List<Person> persons = new ArrayList<Person>();

      persons.add(new Person("Robert","Male", "Single"));
      persons.add(new Person("John","Male", "Married"));
      persons.add(new Person("Laura","Female", "Married"));
      persons.add(new Person("Diana","Female", "Single"));
      persons.add(new Person("Mike","Male", "Single"));
      persons.add(new Person("Bobby","Male", "Single"));

      Criteria male = new CriteriaMale();
      Criteria female = new CriteriaFemale();
      Criteria single = new CriteriaSingle();
      Criteria singleMale = new AndCriteria(single, male);
      Criteria singleOrFemale = new OrCriteria(single, female);

      System.out.println("Males: ");
      printPersons(male.meetCriteria(persons));

      System.out.println("\nFemales: ");
      printPersons(female.meetCriteria(persons));

      System.out.println("\nSingle Males: ");
      printPersons(singleMale.meetCriteria(persons));

      System.out.println("\nSingle Or Females: ");
      printPersons(singleOrFemale.meetCriteria(persons));
   }

   public static void printPersons(List<Person> persons){
      for (Person person : persons) {
         System.out.println("Person : [ Name : " + person.getName()
            +", Gender : " + person.getGender()
            +", Marital Status : " + person.getMaritalStatus()
            +" ]");
      }
   }
}

```

### 组合模式

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

#### 意图
将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

#### 主要解决
它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

#### 如何使用
1. 您想表示对象的部分-整体层次结构（树形结构）
2. 您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象

#### 如何解决
树枝和叶子实现统一接口，树枝内部组合该接口

#### 关键代码
树枝内部组合该接口，并且含有内部属性 List，里面放 Component

#### 应用实例
1. 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数
2. 在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝

#### 优点
1. 高层模块调用简单
2. 节点自由增加

#### 缺点
在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则

#### 使用场景
部分、整体场景，如树形菜单，文件、文件夹的管理

> 注意事项：定义时为具体类

#### 实现

<div align=center><img src='/pic/c&c++/dp-zuhe.svg'/></div>
<center>组合模式</center>

#### 例子

1. 创建 Employee 类，该类带有 Employee 对象的列表
```java
// Employee.java

import java.util.ArrayList;
import java.util.List;

public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List<Employee> subordinates;

   //构造函数
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList<Employee>();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List<Employee> getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return ("Employee :[ Name : "+ name
      +", dept : "+ dept + ", salary :"
      + salary+" ]");
   }
}

```

2. 使用 Employee 类来创建和打印员工的层次结构
```java
// CompositePatternDemo.java

public class CompositePatternDemo {
   public static void main(String[] args) {
      Employee CEO = new Employee("John","CEO", 30000);

      Employee headSales = new Employee("Robert","Head Sales", 20000);

      Employee headMarketing = new Employee("Michel","Head Marketing", 20000);

      Employee clerk1 = new Employee("Laura","Marketing", 10000);
      Employee clerk2 = new Employee("Bob","Marketing", 10000);

      Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
      Employee salesExecutive2 = new Employee("Rob","Sales", 10000);

      CEO.add(headSales);
      CEO.add(headMarketing);

      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);

      headMarketing.add(clerk1);
      headMarketing.add(clerk2);

      //打印该组织的所有员工
      System.out.println(CEO);
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }
   }
}
```

### 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
<br/>
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

#### 意图
动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活

#### 主要解决
一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀

#### 何时使用
在不想增加很多子类的情况下扩展类

#### 如果解决
将具体功能职责划分，同时继承装饰者模式

#### 关键代码
1. Component 类充当抽象角色，不应该具体实现
2. 修饰类引用和继承 Component 类，具体扩展类重写父类方法

#### 应用实例
不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体

#### 优点
装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能

#### 缺点
多层装饰比较复杂

#### 使用场景
1. 扩展一个类的功能
2. 动态增加功能，动态撤销

> 注意事项：可替代继承

#### 实现

<div align=center><img src='/pic/c&c++/dp-zsq.svg'/></div>
<center>装饰器模式</center>

#### 例子
1. 创建一个接口
```java
// Shape.java

public interface Shape {
   void draw();
}
```

2. 创建实现接口的实体类
```java
// Rectangle.java

public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println("Shape: Rectangle");
   }
}
```

```java
// Circle.java

public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Shape: Circle");
   }
}
```

3. 创建实现了 Shape 接口的抽象装饰类
```java
// ShapeDecorator.java

public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;

   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }

   public void draw(){
      decoratedShape.draw();
   }
}
```

4. 创建扩展了 ShapeDecorator 类的实体装饰类
```java
// RedShapeDecorator.java

public class RedShapeDecorator extends ShapeDecorator {

   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);
   }

   @Override
   public void draw() {
      decoratedShape.draw();
      setRedBorder(decoratedShape);
   }

   private void setRedBorder(Shape decoratedShape){
      System.out.println("Border Color: Red");
   }
}
```

5. 使用 RedShapeDecorator 来装饰 Shape 对象
```java
// DecoratorPatternDemo.java

public class DecoratorPatternDemo {
   public static void main(String[] args) {

      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      //Shape redCircle = new RedShapeDecorator(new Circle());
      //Shape redRectangle = new RedShapeDecorator(new Rectangle());
      System.out.println("Circle with normal border");
      circle.draw();

      System.out.println("\nCircle of red border");
      redCircle.draw();

      System.out.println("\nRectangle of red border");
      redRectangle.draw();
   }
}
```

### 外观模式
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
<br/>
这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

#### 意图
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

#### 主要解决
降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口

#### 何时使用
1. 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可
2. 定义系统的入口

#### 如何解决
客户端不与系统耦合，外观类与系统耦合

#### 关键代码
在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好

#### 应用实例
去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便

#### 优点
1. 减少系统相互依赖
2. 提高灵活性
3. 提高了安全性。 

#### 缺点
不符合开闭原则，如果要改东西很麻烦，继承重写都不合适

#### 使用场景
1. 为复杂的模块或子系统提供外界访问的模块
2. 子系统相对独立 
3. 预防低水平人员带来的风险

> 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口

#### 实现

<div align=center><img src='/pic/c&c++/dp-wg.svg'/></div>
<center>外观模式</center>

#### 例子

1. 创建一个接口
```java
// Shape.java

public interface Shape {
   void draw();
}

```

2. 创建实现接口的实体类
```java
// Rectangle.java

public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println("Rectangle::draw()");
   }
}
```

```java
// Square.java

public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}

```

```java
// Circle.java

public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Circle::draw()");
   }
}
```

3. 创建一个外观类

```java
// ShapeMaker.java

public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;

   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }

   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}

```

4. 使用该外观类画出各种类型的形状
```java
// FacadePatternDemo.java

public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();

      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();
   }
}
```

### 享元模式
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
<br/>
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。

#### 意图
运用共享技术有效地支持大量细粒度的对象

#### 主要解决
在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建

#### 何时使用
1. 系统中有大量对象
2. 这些对象消耗大量内存
3. 这些对象的状态大部分可以外部化
4. 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替
5. 系统不依赖于这些对象身份，这些对象是不可分辨的。 

#### 如何解决
用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象

#### 关键代码
用 HashMap 存储这些对象

#### 优点
大大减少对象的创建，降低系统的内存，使效率提高

#### 缺点
提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱

#### 使用场景
1. 系统有大量相似对象
2. 需要缓冲池的场景

> 注意事项：
>   1. 注意划分外部状态和内部状态，否则可能会引起线程安全问题
>   2. 这些类必须有一个工厂对象加以控制

#### 实现

<div align=center><img src='/pic/c&c++/dp-xy.svg'/></div>
<center>享元模式</center>

#### 例子

1. 创建一个接口
```java
// Shape.java

public interface Shape {
   void draw();
}

```

2. 创建实现接口的实体类
```java
// Circle.java

public class Circle implements Shape {
   private String color;
   private int x;
   private int y;
   private int radius;

   public Circle(String color){
      this.color = color;
   }

   public void setX(int x) {
      this.x = x;
   }

   public void setY(int y) {
      this.y = y;
   }

   public void setRadius(int radius) {
      this.radius = radius;
   }

   @Override
   public void draw() {
      System.out.println("Circle: Draw() [Color : " + color
         +", x : " + x +", y :" + y +", radius :" + radius);
   }
}

```

3. 创建一个工厂，生成基于给定信息的实体类的对象

```java
// ShapeFactory.java

import java.util.HashMap;

public class ShapeFactory {
   private static final HashMap<String, Shape> circleMap = new HashMap<>();

   public static Shape getCircle(String color) {
      Circle circle = (Circle)circleMap.get(color);

      if(circle == null) {
         circle = new Circle(color);
         circleMap.put(color, circle);
         System.out.println("Creating circle of color : " + color);
      }
      return circle;
   }
}

```

4. 使用该工厂，通过传递颜色信息来获取实体类的对象
```java
// FlyweightPatternDemo.java

public class FlyweightPatternDemo {
   private static final String colors[] =
      { "Red", "Green", "Blue", "White", "Black" };
   public static void main(String[] args) {

      for(int i=0; i < 20; ++i) {
         Circle circle =
            (Circle)ShapeFactory.getCircle(getRandomColor());
         circle.setX(getRandomX());
         circle.setY(getRandomY());
         circle.setRadius(100);
         circle.draw();
      }
   }
   private static String getRandomColor() {
      return colors[(int)(Math.random()*colors.length)];
   }
   private static int getRandomX() {
      return (int)(Math.random()*100 );
   }
   private static int getRandomY() {
      return (int)(Math.random()*100);
   }
}

```

### 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式

#### 意图
为其他对象提供一种代理以控制对这个对象的访问

#### 主要解决
在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层

#### 何时使用
想在访问一个类时做一些控制

#### 如何解决
增加中间层

#### 应用实例
买火车票不一定在火车站买，也可以去代售点

#### 优点
1. 职责清晰
2. 高扩展性
3. 智能化

#### 缺点
1. 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
2. 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 

#### 使用场景
按职责来划分，通常有以下使用场景： 
1. 远程代理
2. 虚拟代理
3. Copy-on-Write 代理
4. 保护（Protect or Access）代理
5. Cache代理
6. 防火墙（Firewall）代理
7. 同步化（Synchronization）代理
8. 智能引用（Smart Reference）代理

> 注意事项： 
>   1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口
>   2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制

#### 实现

<div align=center><img src='/pic/c&c++/dp-proxy.svg'/></div>
<center>代理模式</center>

#### 例子
1. 创建一个接口
```java
// Image.java

public interface Image {
   void display();
}

```

2. 创建实现接口的实体类
```java
// RealImage.java

public class RealImage implements Image {

   private String fileName;

   public RealImage(String fileName){
      this.fileName = fileName;
      loadFromDisk(fileName);
   }

   @Override
   public void display() {
      System.out.println("Displaying " + fileName);
   }

   private void loadFromDisk(String fileName){
      System.out.println("Loading " + fileName);
   }
}

```

```java
// ProxyImage.java


public class ProxyImage implements Image{

   private RealImage realImage;
   private String fileName;

   public ProxyImage(String fileName){
      this.fileName = fileName;
   }

   @Override
   public void display() {
      if(realImage == null){
         realImage = new RealImage(fileName);
      }
      realImage.display();
   }
}

```

3. 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象
```java
// ProxyPatternDemo.java

public class ProxyPatternDemo {

   public static void main(String[] args) {
      Image image = new ProxyImage("test_10mb.jpg");

      // 图像将从磁盘加载
      image.display();
      System.out.println("");
      // 图像不需要从磁盘加载
      image.display();
   }
}

```

### 责任链模式

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
<br/>
在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

#### 意图
避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止

#### 主要解决
职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了

#### 何时使用
在处理消息的时候以过滤很多道

#### 如何解决
拦截的类都实现统一接口

#### 关键代码
Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去

#### 优点
1. 降低耦合度。它将请求的发送者和接收者解耦
2. 简化了对象。使得对象不需要知道链的结构
3. 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任
4. 增加新的请求处理类很方便

#### 缺点
1. 不能保证请求一定被接收
2. 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用
3. 可能不容易观察运行时的特征，有碍于除错

#### 使用场景
 1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定
 2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
 3. 可动态指定一组对象处理请求。 

#### 实现

<div align=center><img src='/pic/c&c++/dp-zr.svg'/></div>
<center>责任链模式</center>

#### 例子

1. 创建抽象的记录器类
```java
// AbstractLogger.java

public abstract class AbstractLogger {
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;

   protected int level;

   //责任链中的下一个元素
   protected AbstractLogger nextLogger;

   public void setNextLogger(AbstractLogger nextLogger){
      this.nextLogger = nextLogger;
   }

   public void logMessage(int level, String message){
      if(this.level <= level){
         write(message);
      }
      if(nextLogger !=null){
         nextLogger.logMessage(level, message);
      }
   }

   abstract protected void write(String message);

}
```

2. 创建扩展了该记录器类的实体类
```java
// ConsoleLogger.java

public class ConsoleLogger extends AbstractLogger {

   public ConsoleLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {
      System.out.println("Standard Console::Logger: " + message);
   }
}

```

```java
// ErrorLogger.java

public class ErrorLogger extends AbstractLogger {

   public ErrorLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {
      System.out.println("Error Console::Logger: " + message);
   }
}

```

```java
// FileLogger.java

public class FileLogger extends AbstractLogger {

   public FileLogger(int level){
      this.level = level;
   }

   @Override
   protected void write(String message) {
      System.out.println("File::Logger: " + message);
   }
}

```

3. 创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分
```java
// ChainPatternDemo.java

public class ChainPatternDemo {

   private static AbstractLogger getChainOfLoggers(){

      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);

      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);

      return errorLogger;
   }

   public static void main(String[] args) {
      AbstractLogger loggerChain = getChainOfLoggers();

      loggerChain.logMessage(AbstractLogger.INFO, "This is an information.");

      loggerChain.logMessage(AbstractLogger.DEBUG,
         "This is a debug level information.");

      loggerChain.logMessage(AbstractLogger.ERROR,
         "This is an error information.");
   }
}

```

### 命令模式

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

#### 意图
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化

#### 主要解决
在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适

#### 何时使用
在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合

#### 如何解决
通过调用者调用接受者执行命令，顺序：调用者→命令→接受者

#### 关键代码
定义三个角色：
1. received 真正的命令执行对象 
2. Command 
3. invoker 使用命令对象的入口

#### 应用实例
struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command

#### 优点
1. 降低了系统耦合度
2. 新的命令可以很容易添加到系统中去

#### 缺点
使用命令模式可能会导致某些系统有过多的具体命令类

#### 使用场景
认为是命令的地方都可以使用命令模式，比如： 
1. GUI 中每一个按钮都是一条命令
2. 模拟 CMD

> 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展

#### 示意图
<div align=center><img src='/pic/c&c++/dp-ml-1.jpg'/></div>
<center>命令模式示意图</center>

#### 实现
<div align=center><img src='/pic/c&c++/dp-ml-2.jpg'/></div>
<center>命令模式</center>

#### 例子
1. 创建一个命令接口
```java
// Order.java

public interface Order {
   void execute();
}

```

2. 创建一个请求类
```java
// Stock.java

public class Stock {

   private String name = "ABC";
   private int quantity = 10;

   public void buy(){
      System.out.println("Stock [ Name: "+name+",
         Quantity: " + quantity +" ] bought");
   }
   public void sell(){
      System.out.println("Stock [ Name: "+name+",
         Quantity: " + quantity +" ] sold");
   }
}

```

3. 创建实现了 Order 接口的实体类
```java
// BuyStock.java

public class BuyStock implements Order {
   private Stock abcStock;

   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.buy();
   }
}

```

```java
// SellStock.java

public class SellStock implements Order {
   private Stock abcStock;

   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.sell();
   }
}

```

4. 创建命令调用类
```java
// Broker.java

import java.util.ArrayList;
import java.util.List;

public class Broker {
   private List<Order> orderList = new ArrayList<Order>();

   public void takeOrder(Order order){
      orderList.add(order);
   }

   public void placeOrders(){
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}

```

5. 使用 Broker 类来接受并执行命令
```java
// CommandPatternDemo.java

public class CommandPatternDemo {
   public static void main(String[] args) {
      Stock abcStock = new Stock();

      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);

      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);

      broker.placeOrders();
   }
}
```

### 解释器模式
解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

#### 意图
给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子

#### 主要解决
对于一些固定文法构建一个解释句子的解释器

#### 何时使用
如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题

#### 如何解决
构建语法树，定义终结符与非终结符

#### 关键代码
构建环境类，包含解释器之外的一些全局信息，一般是 HashMap

#### 应用实例
编译器、运算表达式计算

#### 优点
1. 可扩展性比较好，灵活
2. 增加了新的解释表达式的方式
3. 易于实现简单文法

#### 缺点
1. 可利用场景比较少
2. 对于复杂的文法比较难维护
3. 解释器模式会引起类膨胀
4. 解释器模式采用递归调用方法

#### 使用场景
1. 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
2. 一些重复出现的问题可以用一种简单的语言来进行表达
3. 一个简单语法需要解释的场景。

> 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替

#### 实现
<div align=center><img src='/pic/c&c++/dp-jsq.jpg'/></div>
<center>解释器模式</center>

#### 例子
1. 创建一个表达式接口
```java
// Expression.java

public interface Expression {
   public boolean interpret(String context);
}

```

2. 创建实现了上述接口的实体类
```java
// TerminalExpression.java

public class TerminalExpression implements Expression {

   private String data;

   public TerminalExpression(String data){
      this.data = data;
   }

   @Override
   public boolean interpret(String context) {
      if(context.contains(data)){
         return true;
      }
      return false;
   }
}

```

```java
// OrExpression.java

public class OrExpression implements Expression {

   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) {
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {
      return expr1.interpret(context) || expr2.interpret(context);
   }
}

```

```java
// AndExpression.java

public class AndExpression implements Expression {

   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) {
      this.expr1 = expr1;
      this.expr2 = expr2;
   }

   @Override
   public boolean interpret(String context) {
      return expr1.interpret(context) && expr2.interpret(context);
   }
}

```

3. InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们
```java
// InterpreterPatternDemo.java

public class InterpreterPatternDemo {

   //规则：Robert 和 John 是男性
   public static Expression getMaleExpression(){
      Expression robert = new TerminalExpression("Robert");
      Expression john = new TerminalExpression("John");
      return new OrExpression(robert, john);
   }

   //规则：Julie 是一个已婚的女性
   public static Expression getMarriedWomanExpression(){
      Expression julie = new TerminalExpression("Julie");
      Expression married = new TerminalExpression("Married");
      return new AndExpression(julie, married);
   }

   public static void main(String[] args) {
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();

      System.out.println("John is male? " + isMale.interpret("John"));
      System.out.println("Julie is a married women? "
      + isMarriedWoman.interpret("Married Julie"));
   }
}

```
### 迭代器模式

这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示
<br/>
迭代器模式属于行为型模式

#### 意图
提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示

#### 主要解决
不同的方式来遍历整个整合对象

#### 何时使用
遍历一个聚合对象

#### 如何解决
把在元素之间游走的责任交给迭代器，而不是聚合对象

#### 关键代码
定义接口：hasNext, next

#### 优点
1. 它支持以不同的方式遍历一个聚合对象
2. 迭代器简化了聚合类
3. 在同一个聚合上可以有多个遍历
4. 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 

#### 缺点
由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性

#### 使用场景
1. 访问一个聚合对象的内容而无须暴露它的内部表示
2. 需要为聚合对象提供多种遍历方式
3. 为遍历不同的聚合结构提供一个统一的接口

> 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据

#### 实现
<div align=center><img src='/pic/c&c++/dp-i.png'/></div>
<center>迭代器模式</center>

#### 例子 

1. 创建接口
```java
// Iterator.java

public interface Iterator {
   public boolean hasNext();
   public Object next();
}

```

```java
// Container.java

public interface Container {
   public Iterator getIterator();
}

```

2. 创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator

```java
// NameRepository.java

public class NameRepository implements Container {
   public String[] names = {"Robert" , "John" ,"Julie" , "Lora"};

   @Override
   public Iterator getIterator() {
      return new NameIterator();
   }

   private class NameIterator implements Iterator {

      int index;

      @Override
      public boolean hasNext() {
         if(index < names.length){
            return true;
         }
         return false;
      }

      @Override
      public Object next() {
         if(this.hasNext()){
            return names[index++];
         }
         return null;
      }
   }
}

```

3. 使用 NameRepository 来获取迭代器，并打印名字
```java
// IteratorPatternDemo.java

public class IteratorPatternDemo {

   public static void main(String[] args) {
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){
         String name = (String)iter.next();
         System.out.println("Name : " + name);
      }
   }
}

```
### 中介者模式
中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。

#### 意图
用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

#### 主要解决
对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理

#### 何时使用
多个类相互耦合，形成了网状结构

#### 如何解决
将上述网状结构分离为星型结构

#### 应用实例
1. 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易
2. 机场调度系统
3. MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者

#### 优点
1. 降低了类的复杂度，将一对多转化成了一对一
2. 各个类之间的解耦
3. 符合迪米特原则

#### 缺点
中介者会庞大，变得复杂难以维护

#### 使用场景
1. 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象
2. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类






