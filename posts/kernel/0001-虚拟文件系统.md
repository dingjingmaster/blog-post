---
title: "虚拟文件系统"
date: 2022-04-13T15:09:22+08:00
tags: ['linux', 'kernel']
categories: ['kernel']
draft: true
---

## Linux虚拟文件系统概述

### 说明

虚拟文件系统(也称为虚拟文件系统交换机)是内核中的软件层，它为用户空间程序提供文件系统接口。它还在内核中提供了一个抽象，允许不同的文件系统实现共存。

VFS系统调用open(2)， stat(2)， read(2)， write(2)， chmod(2)等等都是在进程上下文中调用的。文件系统锁定在文档locking中进行了描述。

### 目录条目缓存(dcache)

VFS实现了open(2)、stat(2)、chmod(2)和类似的系统调用。传递给它们的pathname参数被VFS用来搜索目录条目缓存(也称为dentry缓存或dcache)。这提供了一种非常快速的查找机制，可以将路径名(filename)转换为特定的dentry。dentry 仅存在于RAM中，从不保存到磁盘:它们只是为了性能而存在。

dentry 缓存是整个文件空间的视图。由于大多数计算机不能在同一时间将所有 dentry 放入 RAM 中，缓存中的一些位缺失了。为了将路径名解析为 dentry, VFS 可能不得不在此过程中创建 dentry，然后加载inode。这是通过查找 inode 来完成的。

### Inode对象

单个 dentry 通常有一个指向 inode 的指针。inode 是文件系统对象，例如常规文件、目录、fifo 和其他对象。它们要么在磁盘上(对于块设备文件系统)，要么在内存中(对于伪文件系统)。磁盘上的 inode 在需要时被复制到内存中，对 inode 的更改被写回磁盘。一个 inode 可以被多个 dentry 指向(例如，硬链接)。

要查找 inode，需要 VFS 调用父目录 inode 的 lookup() 方法。此方法由 inode 所在的特定文件系统实现安装。一旦VFS拥有了所需的 dentry (以及 inode)，我们就可以执行所有那些枯燥的操作，比如打开(2)文件，或者stat(2)它来查看 inode 数据。stat(2)操作相当简单:一旦 VFS 拥有 dentry，它就会查看 inode 数据，并将其中一些数据传回用户空间。

### 文件对象

打开文件需要另一个操作: 分配文件结构(这是文件描述符的内核端实现)。用一个指向 dentry 的指针和一组文件操作成员函数初始化新分配的文件结构。这些数据来自 inode 数据。然后调用 open() 文件方法，以便特定的文件系统实现能够完成它的工作。您可以看到，这是由VFS执行的另一个切换。文件结构被放置到进程的文件描述符表中。

读取、写入和关闭文件(以及其他各种VFS操作)是通过使用用户空间文件描述符来获取适当的文件结构，然后调用所需的文件结构方法来完成所需的操作。只要文件处于打开状态，它就会继续使用 dentry，这意味着 VFS inode 仍在使用中。

### 注册和挂载文件系统

注册和注销一个文件系统，使用以下API函数:

```c
#include <linux/fs.h>

extern int register_filesystem(struct file_system_type *);
extern int unregister_filesystem(struct file_system_type *);
```

传递的 `struct file_system_type` 描述您的文件系统。当请求将文件系统挂载到名称空间中的目录时，VFS 将为特定的文件系统调用适当的 `mount()` 方法。引用由`->mount()` 返回的树的新 vfmount 将被附加到挂载点，因此当路径名解析到达挂载点时，它将跳到该 vfmount的 根目录。

您可以在文件 `/proc/filesystems` 中看到注册到内核的所有文件系统。

#### `struct file_system_type`

描述文件系统。从内核2.6.39开始，定义了以下成员:

```c
struct file_system_type 
{
        const char *name;
        int fs_flags;
        struct dentry *(*mount) (struct file_system_type *, int,
                                 const char *, void *);
        void (*kill_sb) (struct super_block *);
        struct module *owner;
        struct file_system_type * next;
        struct list_head fs_supers;
        struct lock_class_key s_lock_key;
        struct lock_class_key s_umount_key;
};
```
|结构体成员|说明|
|:---|:---|
|`name`|文件系统类型的名称，如“ext2”、“iso9660”、“msdos”等|
|`fs_flags`|各种标志(例如`FS_REQUIRES_DEV`, `FS_NO_DCACHE`等)|
|`mount`|当应该安装这个文件系统的新实例时要调用的方法<br/>参数:<br/>`struct file_system_type *fs_type`描述由特定文件系统代码部分初始化的文件系统<br/>`int flags`挂载标记<br/>`const char *dev_name`要挂载的设备<br/>`void *data`任意的挂载选项，通常以ASCII字符串的形式出现(参见“挂载选项”一节)|
|`kill_sb`|当应该关闭该文件系统的实例时要调用的方法|
|`owner`|用于VFS内部使用:在大多数情况下，你应该初始化`THIS_MODULE`。|
|`next`|用于VFS内部使用:你应该初始化为NULL|

> `s_lock_key`, `s_umount_key`: lockdep-specific

`mount()`方法必须返回调用者请求的树的根目录。必须获取对其超级块的活动引用，并锁定该超级块。失败时，它应该返回`ERR_PTR`(错误)。

参数与`mount(2)`的参数相匹配，它们的解释取决于文件系统类型。例如，对于块文件系统，`dev_name` 被解释为块设备名，打开该设备，如果它包含一个合适的文件系统映像，该方法相应地创建并初始化`struct super_block`，将其根 `dentry` 返回给调用者。

`->mount()`可以选择返回一个现有文件系统的子树——它不需要创建一个新的。从调用者的角度来看，主要的结果是在(子)树的根处对`dentry`的引用;创建新的超级块是一个常见的副作用。

`mount()`方法填充的超块结构中最有趣的成员是 “`s_op`” 字段。这是一个指向 “`struct super_operations`” 的指针，它描述了文件系统实现的下一层。

通常，文件系统使用通用的`mount()`实现之一，并提供一个`fill_super()`回调函数。一般变体有:
||说明|
|:---|:---|
|`mount_bdev`|挂载驻留在块设备上的文件系统|
|`mount_nodev`|挂载一个没有被设备支持的文件系统|
|`mount_single`|挂载一个在所有挂载之间共享实例的文件系统|

`fill_super()`回调实现有以下参数:

||说明|
|:---|:---|
|`struct super_block *sb`|超级块结构。回调函数必须正确地初始化它|
|`void *data`|任意的挂载选项，通常以ASCII字符串的形式出现(参见“挂载选项”一节)|
|`int silent`|是否对错误保持沉默|

#### 超级块结构

一个超级块对象表示一个挂载的文件系统

##### `struct super_operations`

这将描述VFS如何操作文件系统的超级块。从内核2.6.22开始，定义了以下成员:

```c
struct super_operations 
{
        struct inode *(*alloc_inode)(struct super_block *sb);
        void (*destroy_inode)(struct inode *);

        void (*dirty_inode) (struct inode *, int flags);
        int (*write_inode) (struct inode *, int);
        void (*drop_inode) (struct inode *);
        void (*delete_inode) (struct inode *);
        void (*put_super) (struct super_block *);
        int (*sync_fs)(struct super_block *sb, int wait);
        int (*freeze_fs) (struct super_block *);
        int (*unfreeze_fs) (struct super_block *);
        int (*statfs) (struct dentry *, struct kstatfs *);
        int (*remount_fs) (struct super_block *, int *, char *);
        void (*clear_inode) (struct inode *);
        void (*umount_begin) (struct super_block *);

        int (*show_options)(struct seq_file *, struct dentry *);

        ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
        ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
        int (*nr_cached_objects)(struct super_block *);
        void (*free_cached_objects)(struct super_block *, int);
};
```
除非另有说明，否则调用所有方法时不会持有任何锁。这意味着大多数方法都可以安全地阻塞。所有的方法都只能从进程上下文中调用(即不是从中断处理程序或下半部调用)。

||说明|
|:-----|:---|
|alloc\_inode|这个方法被`alloc_inode()`调用来为`inode`结构分配内存并初始化它。如果这个函数没有定义，则分配一个简单的`struct inode`。通常，`alloc_inode`会被用来分配一个更大的结构体，其中包含一个嵌入在其中的结构体`inode`|
|destroy\_inode|`destroy_inode()`调用这个方法来释放分配给`inode`结构的资源。只有在定义了`->alloc_inode` 并简单地撤销`->alloc_inode` 所做的任何操作时才需要|
|dirty\_inode|当`inode`被标记为`dirty`时，`VFS`将调用此方法。这是专门针对被标记为`dirty`的`inode`本身，而不是它的数据。如果更新需要被`fdatasync()`持久化，那么`I_DIRTY_DATASYNC`将在`flags`参数中设置|
|write\_inode|当`VFS`需要将`inode`写入磁盘时，将调用此方法。第二个参数指示写是否应该是同步的，不是所有的文件系统都检查这个标志|
|drop\_inode|当删除对`inode`的最后一次访问时调用，并持有`inode->i_lock`自旋锁。<br/>这个方法应该是`NULL`(普通的UNIX文件系统语义)或者“`generic_delete_inode`”(对于不想缓存`inode`的文件系统——这导致无论`i_nlink`的值是多少，都要调用“`delete_inode`”)<br/>“`generic_delete_inode()`”的行为相当于在`put_inode()`的情况下使用“`force_delete`”的旧实践，但不具有“`force_delete()`”方法的竞争|
|delete\_inode|当VFS想要删除一个inode时调用|
|put\_super|当VFS希望释放超级块(即卸载)时调用。在超级块锁被持有的情况下调用|
|sync\_fs|当VFS写入与超级块相关的所有脏数据时调用。第二个参数指示该方法是否应该等待到写操作完成。可选的|
|freeze\_fs|当VFS锁定文件系统并强制它进入一致状态时调用。该方法目前由逻辑卷管理器(LVM)使用|
|unfreeze\_fs|当VFS解锁文件系统并使其再次可写时调用|
|statfs|当VFS需要获取文件系统统计信息时调用|
|remount\_fs|重新安装文件系统时调用。这是在持有内核锁的情况下调用的|
|clear\_inode|VFS清除inode。可选|
|umount\_begin|当VFS卸载文件系统时调用|
|show\_options|由VFS调用，以显示 `/proc/<pid>/mounted` 的挂载选项。(请参阅“Mount Options”一节)|
|quota\_read|由VFS调用从文件系统配额文件中读取|
|quota\_write|由VFS调用来写入文件系统配额文件|
|nr\_cached\_objects|由sb缓存收缩函数为文件系统调用，以返回它包含的可缓存对象的数量。可选的|
|free\_cache\_objects|由sb缓存收缩函数为文件系统调用，扫描指示的对象数量，以试图释放它们。可选，但任何实现此方法的文件系统都需要实现`->nr_cached_objects`，以便正确调用它。<br/>我们无法处理文件系统可能遇到的任何错误，因此使用void返回类型。如果VM在`GFP_NOFS`条件下试图回收，则永远不会调用这个函数，因此这个方法本身不需要处理这种情况。<br/>实现必须在任何已完成的扫描循环中包含有条件的重调度调用。这使得VFS能够确定适当的扫描批处理大小，而不必担心实现是否会因为大的扫描批处理大小而导致延迟问题。|

设置inode的人负责填写“`i_op`”字段。这是一个指向“`struct inode_operations`”的指针，它描述了可以在单个inode上执行的方法。

##### `struct xattr_handlers`

在支持扩展属性(xattrs)的文件系统上，`s_xattr`超级块字段指向一个以null结束的xattr处理程序数组。扩展属性是` name:value`对。

||说明|
|:---|:---|
|name|指示处理程序将属性与指定的名称匹配(例如“`system.posix_acl_access`”);前缀字段必须为NULL|
|prefix|表明该处理程序匹配所有带有指定名称前缀的属性(例如"user.");name字段必须为NULL|
|list|确定是否应该为特定`dentry`列出与此`xattr`处理程序匹配的属性。由一些`listxattr`实现使用，如`generic_listxattr`|
|get|由VFS调用以获取特定扩展属性的值。这个方法由`getxattr(2)`系统调用调用|
|set|由VFS调用以设置特定扩展属性的值。当新值为NULL时，调用该函数来删除特定的扩展属性。这个方法由`setxattr(2)`和`removexattr(2)`系统调用来调用|

当文件系统的`xattr`处理程序没有一个与指定的属性名匹配，或者当文件系统不支持扩展属性时，各种`*xattr(2)`系统调用返回`-EOPNOTSUPP`。

#### `inode`结构

inode对象表示文件系统中的对象

##### `struct inode_operations`

这将描述VFS如何操作文件系统中的inode。从内核2.6.22开始，定义了以下成员:

```c
struct inode_operations 
{
        int (*create) (struct user_namespace *, struct inode *,struct dentry *, umode_t, bool);
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        int (*link) (struct dentry *,struct inode *,struct dentry *);
        int (*unlink) (struct inode *,struct dentry *);
        int (*symlink) (struct user_namespace *, struct inode *,struct dentry *,const char *);
        int (*mkdir) (struct user_namespace *, struct inode *,struct dentry *,umode_t);
        int (*rmdir) (struct inode *,struct dentry *);
        int (*mknod) (struct user_namespace *, struct inode *,struct dentry *,umode_t,dev_t);
        int (*rename) (struct user_namespace *, struct inode *, struct dentry *,
                       struct inode *, struct dentry *, unsigned int);
        int (*readlink) (struct dentry *, char __user *,int);
        const char *(*get_link) (struct dentry *, struct inode *,
                                 struct delayed_call *);
        int (*permission) (struct user_namespace *, struct inode *, int);
        struct posix_acl * (*get_acl)(struct inode *, int, bool);
        int (*setattr) (struct user_namespace *, struct dentry *, struct iattr *);
        int (*getattr) (struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int);
        ssize_t (*listxattr) (struct dentry *, char *, size_t);
        void (*update_time)(struct inode *, struct timespec *, int);
        int (*atomic_open)(struct inode *, struct dentry *, struct file *,
                           unsigned open_flag, umode_t create_mode);
        int (*tmpfile) (struct user_namespace *, struct inode *, struct dentry *, umode_t);
        int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int);
        int (*fileattr_set)(struct user_namespace *mnt_userns,
                            struct dentry *dentry, struct fileattr *fa);
        int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);
};
```
> 同样，调用所有方法时不会持有任何锁，除非另有说明

||说明|
|:---|:---|
|create|由`open(2)`和`create(2)`系统调用调用。只有当您想要支持常规文件时才需要。你得到的`dentry`不应该有`inode`(也就是说，它应该是一个负dentry)。在这里，您可能会使用`dentry`和新创建的`inode`调用`d_instantiate()`|
|lookup|当VFS需要在父目录中查找inode时调用。要找的名字在dentry中找到。这个方法必须调用`d_add()`将找到的inode插入dentry中。inode结构中的“`i_count`”字段应该递增。如果指定的inode不存在，则应该在dentry中插入NULL inode(这称为负dentry)。从这个例程返回错误代码必须只在真正的错误时执行，否则使用系统调用(如create(2)、mknod(2)、mkdir(2)等)创建索引节点将会失败。如果你想重载dentry方法，那么你应该在dentry中初始化“`d_dop`”字段;这是一个指向struct“`dentry_operations`”的指针。调用此方法时，将保持目录inode信号量|
|link|由link(2)系统调用调用。只有当你想支持硬链接时才需要。您可能需要调用`d_instantiate()`，就像在create()方法中一样|
|unlink||
|symlink||
|mkdir||
|rmdir||
|mknod||
|rename||
|get\_link||
|readlink||
|permission||
|setattr||
|getattr||
|listxattr||
|update\_time||
|atomic\_open||
|tmpfile||
|fileattr\_get||
|fileattr\_set||

#### 地址空间对象(The Address Space Object)

地址空间对象用于对页面缓存中的页面进行分组和管理。它可以用来跟踪文件(或其他任何东西)中的页面，也可以跟踪文件部分到进程地址空间的映射。

地址空间可以提供许多不同但相关的服务。这些方法包括传递内存压力、按地址查找页面，以及跟踪标记为Dirty或Writeback的页面。

第一种方法可以独立于其他方法使用。VM可以尝试写脏页以清理它们，也可以尝试释放干净的页以重用它们。为此，它可以在脏页面上调用`->writepage`方法，在干净页面上使用pagprivate设置调用`->releasepage`方法。没有pagprivate和没有外部引用的Clean页面将被释放，而不会通知`address_space`。

为了实现这个功能，需要使用`lru_cache_add`将页面放置在LRU上，并且需要在使用页面时调用`mark_page_active`。

页面通常保存在根树索引 `->index`中。这个树维护关于每个页面的`PG_Dirty`和`PG_Writeback`状态的信息，因此可以快速找到带有这两个标志的页面。

`Dirty`标记主要由`mpage_writepages`, 默认的`->writepages`方法使用。它使用标记来查找要调用`->writepage`的脏页。如果没有使用`mpage_writepages`(即地址提供了自己的`->writepages`)，则`PAGECACHE_TAG_DIRTY`标记几乎是未使用的。`Write_inode_now`和`sync_inode`确实使用它(通过`__sync_single_inode`)来检查`->writepages`写页面是否已经成功写入整个地址空间。

Writeback标签由`filemap*wait*`和`sync_page*`函数使用，通过`filemap_fdatawait_range`来等待所有的`Writeback`完成。

一个`address_space`处理程序可以附加额外的信息到一个页面，通常使用'`struct page`'中的'`private`'字段。如果附加了这样的信息，那么应该设置`PG_Private`标志。这将导致各种VM例程对`address_space`处理程序进行额外调用，以处理该数据。

地址空间充当存储和应用程序之间的中间体。每次将整个页面的数据读入地址空间，并通过复制页面或内存映射页面的方式提供给应用程序。应用程序将数据写入地址空间，然后通常以整个页面的形式写回存储，但是地址空间对写大小有更好的控制。

读取过程本质上只需要'`readpage`'。写过程比较复杂，使用`write_begin`/`write_end`或`dirty_folio`将数据写入`address_space`, `writepage`和`writepio`将数据回写到存储空间。

在一个地址空间中添加和删除页面受到`inode`的`i_mutex`的保护

当数据写入页面时，应该设置`PG_Dirty`标志。它通常保持设置，直到`writepage`要求写它。这将清除`PG_Dirty`并设置`PG_Writeback`。实际上，它可以在`PG_Dirty`清楚之后的任何时候被写入。一旦知道它是安全的，`PG_Writeback`将被清除。

Writeback使用`writeback_control`结构来指导操作。这为写页面和写页面操作提供了一些关于回写请求的性质和原因的信息，以及执行回写请求的约束条件。它还用于将关于写页面或写页面请求的结果的信息返回给调用者。

#### 处理回写过程中的错误(Handling errors during writeback)

大多数进行缓冲`I/O`的应用程序都会周期性地调用文件同步调用(`fsync`, `fdatasync`, `msync`或`sync_file_range`)，以确保写入的数据已经到达了备份存储区。当回写过程中出现错误时，他们希望在发出文件同步请求时报告该错误。在一个请求报告了错误之后，同一个文件描述符上的后续请求应该返回0，除非在上一次文件同步之后发生了更多的回写错误。

在理想的情况下，内核只会报告文件描述的错误，这些文件的写操作后来没有被写回。然而，通用的页面缓存基础结构并不跟踪那些污染了每个单独页面的文件描述，因此不可能确定哪些文件描述符应该返回错误。

相反，内核中通用的回写错误跟踪基础设施解决了向`fsync`报告错误的问题，以便在错误发生时对所有打开的文件描述进行`fsync`。在有多个写入器的情况下，所有写入器都将在随后的`fsync`中返回一个错误，即使通过特定文件描述符完成的所有写入都成功了(或者即使对该文件描述符根本没有写操作)。

希望使用此基础设施的文件系统应该在发生错误时调用`mapping_set_error`将错误记录在`address_space`中。然后，在从`pagecache`回写数据到他们的`file->fsync`操作之后，他们应该调用`file_check_and_advance_wb_err`来确保结构文件的错误游标已经前进到由备份设备发出的错误流中的正确点。

#### `struct address_space_operations`

这将描述VFS如何操作文件系统中文件到页面缓存的映射。定义了以下成员:

```c
struct address_space_operations 
{
        int (*writepage)(struct page *page, struct writeback_control *wbc);
        int (*readpage)(struct file *, struct page *);
        int (*writepages)(struct address_space *, struct writeback_control *);
        bool (*dirty_folio)(struct address_space *, struct folio *);
        void (*readahead)(struct readahead_control *);
        int (*write_begin)(struct file *, struct address_space *mapping,
                           loff_t pos, unsigned len, unsigned flags,
                        struct page **pagep, void **fsdata);
        int (*write_end)(struct file *, struct address_space *mapping,
                         loff_t pos, unsigned len, unsigned copied,
                         struct page *page, void *fsdata);
        sector_t (*bmap)(struct address_space *, sector_t);
        void (*invalidate_folio) (struct folio *, size_t start, size_t len);
        int (*releasepage) (struct page *, int);
        void (*freepage)(struct page *);
        ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);
        /* isolate a page for migration */
        bool (*isolate_page) (struct page *, isolate_mode_t);
        /* migrate the contents of a page to the specified target */
        int (*migratepage) (struct page *, struct page *);
        /* put migration-failed page back to right list */
        void (*putback_page) (struct page *);
        int (*launder_folio) (struct folio *);

        bool (*is_partially_uptodate) (struct folio *, size_t from,
                                       size_t count);
        void (*is_dirty_writeback) (struct page *, bool *, bool *);
        int (*error_remove_page) (struct mapping *mapping, struct page *page);
        int (*swap_activate)(struct file *);
        int (*swap_deactivate)(struct file *);
};
```

||说明|
|:---|:---|
|writepage|由虚拟机调用来写脏页到备份存储。这可能是由于数据完整性的原因(如“sync”)，或释放内存(flush)。这种区别可以在`wbc->sync_mode`中看到。`PG_Dirty`标志已被清除并且`pagellocked`为真。`writepage`应该开始写，应该设置`PG_Writeback`，并且应该确保在写操作完成时以同步或异步方式解锁页面。<br/>如果`wbc->sync_mode`为`WB_SYNC_NONE`，`->writepage`在有问题时不必太费力，如果这样做更容易的话(例如，由于内部依赖)，可以选择从映射中写出其他页面。如果它选择不开始写，它应该返回`AOP_WRITEPAGE_ACTIVATE`，这样VM就不会继续调用页面上的`->writepage`。<br/>See the file “Locking” for more details.|
|readpage||
|writepages||
|dirty\_folio||
|readahead||
|write\_begin||
|write\_end||
|bmap||
|invalidate\_folio||
|releasepage||
|freepage||
|direct\_IO||
|isolate\_page||
|migrate\_page||
|putback\_page||
|launder\_folio||
|is\_partially\_uptodate||
|is\_dirty\_writeback||
|error\_remove\_page||
|swap\_activate||
|swap\_deactivate||

#### 文件对象(The File Object)

文件对象表示进程打开的文件。这在POSIX术语中也称为“打开文件描述”。

##### `struct file_operations`

这将描述VFS如何操作打开的文件。从内核4.18开始，定义了以下成员:

```c
struct file_operations 
{
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, bool spin);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset,
                          loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
#endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
                                   struct file *file_out, loff_t pos_out,
                                   loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
};
```

> 同样，调用所有方法时不会持有任何锁，除非另有说明。

||说明|
|:---|:---|
|llseek||
|read||
|read\_iter||
|write||
|write\_iter||
|iopoll||
|iterate||
|iterate\_shared||
|poll||
|unlocked\_ioctl||
|compat\_ioctl||
|mmap||
|open||
|flush||
|release||
|fsync||
|fasync||
|lock||
|get\_unmapped\_area||
|check\_flags||
|flock||
|splice\_write||
|splice\_read||
|setlease||
|fallocate||
|copy\_file\_range||
|remap\_file\_range||
|fadvise||

> 注意，文件操作是由inode所在的特定文件系统实现的。当打开一个设备节点(字符或特殊块)时，大多数文件系统将调用VFS中的特殊支持例程，它将定位所需的设备驱动程序信息。这些支持例程将文件系统文件操作替换为设备驱动程序的操作，然后继续为文件调用新的open()方法。这就是在文件系统中打开设备文件最终调用设备驱动程序open()方法的方式。

#### 缓冲目录条目(Directory Entry Cache)

##### `struct dentry_operations`

这将描述文件系统如何重载标准dentry操作。dentry和dcache是VFS和各个文件系统实现的域。设备驱动程序与此无关。这些方法可以设置为NULL，因为它们要么是可选的，要么VFS使用默认值。从内核2.6.22开始，定义了以下成员:

```c
struct dentry_operations 
{
        int (*d_revalidate)(struct dentry *, unsigned int);
        int (*d_weak_revalidate)(struct dentry *, unsigned int);
        int (*d_hash)(const struct dentry *, struct qstr *);
        int (*d_compare)(const struct dentry *,
                         unsigned int, const char *, const struct qstr *);
        int (*d_delete)(const struct dentry *);
        int (*d_init)(struct dentry *);
        void (*d_release)(struct dentry *);
        void (*d_iput)(struct dentry *, struct inode *);
        char *(*d_dname)(struct dentry *, char *, int);
        struct vfsmount *(*d_automount)(struct path *);
        int (*d_manage)(const struct path *, bool);
        struct dentry *(*d_real)(struct dentry *, const struct inode *);
};
```

- d\_revalidate
- \_weak\_revalidate
- d\_hash
- d\_compare
- d\_delete
- d\_init
- d\_release
- d\_iput
- d\_dname
- d\_automount
- d\_manage
- d\_real

每个dentry都有一个指向父dentry的指针，以及一个子dentry的哈希列表。子条目基本上就像目录中的文件。

#### 目录条目缓冲API(Directory Entry Cache API)

有许多函数定义允许文件系统操作dentry:
- dget
- dput
- d\_drop
- d\_delete
- d\_add
- d\_instantiate
- d\_lookup

#### 挂载操作(Mount Options)

##### 解析选项

在挂载和重新挂载文件系统时，会传递一个字符串，其中包含用逗号分隔的挂载选项列表。选项可以有以下两种形式:
```
option option=value
```
> <linux/parser.h> 头文件定义了一个帮助解析这些选项的API。关于如何在现有的文件系统中使用它，有很多例子。

##### 显示选项

如果文件系统接受挂载选项，它必须定义`show_options()`来显示所有当前活动的选项。规则是:
- 选项必须显示哪些不是默认值，或者它们的值与默认值不同
- 可以显示默认启用或有默认值的选项

仅在挂载助手和内核之间内部使用的选项(如文件描述符)，或仅在挂载期间起作用的选项(如控制日志创建的选项)不受上述规则的约束。

上面这些规则的根本原因是为了确保一个挂载可以根据 `proc/mounts` 中找到的信息被精确地复制(例如umounting和mount)

#### 参考资源

- [Creating Linux virtual filesystems. 2002](https://lwn.net/Articles/13325/)
- [The Linux Virtual File-system Layer by Neil Brown. 1999](http://www.cse.unsw.edu.au/~neilb/oss/linux-commentary/vfs.html)
- [A tour of the Linux VFS by Michael K. Johnson. 1996](https://www.tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html)
- [A small trail through the Linux kernel by Andries Brouwer. 2001](https://www.win.tue.nl/~aeb/linux/vfs/trail.html)

## 路径名搜索
## Linux文件系统API摘要
## splice and pipes
## 锁
## 文件目录锁
## 开发文件系统
## Linux目录的通知
## Fiemap Ioctl
## Linux内核中的文件管理
## 文件系统挂载API
## Quota subsystem
## The seq\_file Interface
## Shared Subtrees
## Idmappings
## 自动安装支持
## 文件系统缓存




