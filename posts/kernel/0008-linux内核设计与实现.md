---
title: "Linux内核设计与实现"
date: 2022-09-09T08:47:11+08:00
tags: ['linux', 'kernel', 'kernel-2.6.34']
categories: ['linux']
draft: true
---

> 书中内容基于 `kernel-2.6.34` 版本内核，书籍名《Linux内核设计与实现》

## Linux内核简介

### kernel许可协议

linux kernel 基于 (GPL v2)作为限制条款，保障每个人都可以自由获取、修改内核，但是也要让得到你修改内核的人同时也享有你曾经享有的权利——开源全部源代码。

## 从内核出发

### 内核源码树

|目录|描述|
|:---|:---|
|arch|特定体系结构的源码|
|block|块设备I/O层|
|crypto|加密API|
|Documentation|内核源码文档|
|drivers|设备驱动程序|
|firmware|使用某些驱动程序而需要的设备固件|
|fs|VFS和各种文件系统|
|include|内核头文件|
|init|内核引导和初始化|
|ipc|进程间通信代码|
|kernel|像调度程序这样的核心子系统|
|lib|通用内核函数|
|mm|内存管理子系统和VM|
|net|网络子系统|
|samples|示例代码|
|scripts|编译内核所用的脚本|
|security|Linux安全模块|
|sound|语音子系统|
|usr|早期用户空间代码(所谓的initramfs)|
|tools|在linux开发中有用的工具|
|virt|虚拟化基础结构|

### 配置内核

1. `make config`
2. `make menuconfig`
3. `make gconfig`
4. `make defconfig`：基于默认配置来编译内核
5. `make oldconfig`：基于已有配置来编译内核

### 编译内核
### 安装内核
### 安装内核模块
### 生成initramfs
### 更新引导

> 编译内核时候会在内核代码根目录下创建一个 System.map 文件，这时一份符号对照表，用来将内核符号和他们的起始地址对应起来，调试时候用来吧内存地址翻译成容易理解的函数名和变量名。

### 内核开发的特点

- 内核编程时候既不能访问C库，也不能访问标准的C头文件(常用C库函数在linux内核中已经被实现)
- 内核编程时候必须使用 GNU C。
- 内核编程时缺乏用户空间那样的内存保护机制。
- 内核编程时候难以执行浮点运算。
- 内核给每个进程只有一个很小的定长堆栈。
- 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。
- 要考虑可移植性

### Kernel头文件使用

- 基本的头文件位于内核源码顶级目录下的`include` 目录中。例如：头文件<linux/inotify.h>对应内核源码树中的`include/linux/inotify.h`
- 体系结构相关的头文件集位于内核源代码树的 `arch/<archiecture>/include/asm`目录下。梅核代码通过以 `asm/`为前缀的方式包含这些头文件，例如：<asm/ioctl.h>

### kernel 打印日志

内核中无`printf()`函数，但是它提供了`printk()`，`printk()`负责把格式化好的字符串拷贝到内核日志缓冲区上，`printf()`和`printk()`之间的一个显著区别在于，`printk()`允许你通过指定一个标志来设置优先级。syslogd会根据这个优先级标志来决定在什么地方显示这条系统信息。
```
printk(KERN_ERR "this is an error\n");
```

### GNU C

Linux内核是用C语言编写的，但是内核不完全符合ANSIC标准，只要有可能，内核开发者总是要用到 gcc 提供的多语言扩展部分(gcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其它代码)。
<br/>

内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性，最早只有 gcc 提供足够多的扩展特性，才可以用来编译linux内核。
<br/>

以下是一些内核代码中使用到的C语言扩展部分：
#### 内联函数(inline)

C99 和 GNU C 都支持内联函数。函数会在调用位置展开，消除函数调用和返回带来的开销(寄存器存储和恢复)。不过也有缺点，这会导致代码变长，意味着占用更多的内存空间或者占用更多的指令缓存。内核开发者通常把那些对事件要求比较高，本身长度又比较短的函数定义成内联函数。如果一个函数较大，会被反复调用，且没有特别的时间上的限制，我们不赞成把它做成内联函数。

定义一个内联函数时候，需要使用`static`作为关键字，并且用`inline`限定它。比如：`static inline void wolf(unsigned long tail_size);`

内核中，为了类型安全和易读性，有限使用内联函数，而不是复杂的宏。

#### 汇编内联

gcc 编译器支持在C函数中嵌入汇编指令。当然在内核编程的时候，只有知道对应的体系结构才能使用这个功能。

通常使用 asm() 指令嵌入汇编代码，例如：
```c
unsigned int low, high; // low 和 high 分别包含64位时间戳的低32位和高32位
asm volatile("rdtsc" : "=a" (low), "=d" (high));
```

Linux 内核混合使用了C语言和汇编语言。在偏近体系结构的底层或对执行事件要求严格的地方，一般使用的是汇编语言。而内核其它部分的大部分代码是用C语言编写的。

#### 分支声明

对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核把这条指令封装成了宏，比如`likely()`和`unlikely()`，这样使用起来比较方便。
<br/>

例如下面是一个条件选择语句：
```c
if (error) {
    /* ... */
}
```
如果想要把这个选择标记成绝少发生的分支：
```c
// 我们认为 error 绝大部分事件都会是0
if (unlikely(error)) {
    /* ... */
}
```

如果想要把一个分支标记位通常为真的选择：
```c 
// 我们认为 success 通常都不会为0
if (likely(success)) {
    /* ... */
}
```
> 在使用这两个宏之前，一定要搞清楚这个条件，如果判断不准确，那么性能反而会下降。

#### 没有内存保护机制

如果用户程序访问非法内存，内核会发现这个错误，发送 SIGSEGV 信号，并结束整个进程。

如果内核自己非法访问内存，就会导致 oops，且结果很难控制。

另外内核中的内存并不分页，也就是说，你每用掉一个字节，物理内存就减少一个字节。所以，在你想往内核里加入新功能时候要记住这一点。

#### 不要轻易在内核中使用浮点数

在用户空间的进程内使用浮点操作的时候，内核会完成从整数操作模式到浮点数操作模式转换。在执行浮点指令时候因体系结构不同，内核的选择也不同，但是，内核通常捕获陷阱并着手于整数到浮点方式的转变。

与用户空间进程不同，内核并不能完美地支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时候，除了要人工保存和恢复浮点寄存器，还有其它一些琐碎的事情要做。如果要直截了当的回答，那就是：别这样做，除非一些极少情况，否则别在内核中使用浮点操作。

#### 容积小而固定的栈

用户空间的程序可以从栈上分配大量的空间来存放变量，甚至巨大的结构体或者是包含数以千计的数据项的数组都没问题。之所以可以这么做，是因为用户空间的栈本身比较打，而且还能动态增长。

内核堆栈的准确大小随体系结构而变。在 X86 上，栈的大小在编译时候配置，可以是 4KB 也可以是 8KB。

历史上说，内核栈的大小是两页，32位机器内核栈是 8KB，而 64位机器是 16KB，这个固定不变的，每个处理器都有自己的栈。

#### 同步和并发

内核很容易产生竞争条件。和单线程的用户空间程序不同，内核的许多特性都要求能够并发地访问共享数据，这就要求有同步机制以保证不出现竞争条件，特别是：

- Linux是抢占多任务操作系统。内核的进程调度程序即兴对进程进行调度和重新调度。内核必须和这些任务同步。
- Linux内核支持对称多处理器系统(SMP)。所以，如果没有适当的保护，同时在两个或两个以上的处理器上执行的内核代码很可能会同时访问共享的同一个资源。
- 中断是异步到来的，完全不顾及当前正在执行的代码。也就是说，如果不加以适当的保护，中断完全有可能在代码访问资源的时候到来，这样，中断处理程序就有可能访问同一资源。
- Linux内核可以抢占。所以，如果不加以适当的保护，内核中一段正在执行的代码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资源。

常用的解决竞争的办法是`自旋锁`和`信号量`。

#### 可移植性的重要性

大部分 C 代码应该与体系结构无关，在许多不同体系结构的计算机上都能编译和执行，因此，必须把与体系结构相关的代码从内核代码树的特定目录中适当地分离出来。

诸如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。

## 进程管理

- 进程定义和相关概念，比如：线程
- Linux内核如何管理进程
- 进程在内核中的生命周期

**进程管理是整个操作系统的心脏所在**

### 进程

进程是处于执行期的程序(目标码存放在某种介质上)。但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，text section)。通常进程还要包含其它资源，
像打开的文件、挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，当然还包括用来存放全局变量的数据段等。
实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明的管理所有细节。

执行线程，简称线程，是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。梅核调度的对象是线程，而不是进程。
在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包含多个线程的多线程程序司空见惯。对Linux而言，并不特别区分线程和进程。
<br/>

在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。虽然实际上可能是许多进程正在分享一个处理器，但是虚拟处理器给进程一个假象，
让这些进程觉得自己在独享处理器。
<br/>

程序不是进程，进程是处于执行期间程序及其相关资源的总称。
<br/>

Linux通过调用 `fork()` 复制一个现有进程来创建一个全新的进程。调用 `fork()` 的进程称为父进程，新产生的进程称为 `子进程`。在调用结束时候，
在返回点这个相同位置上，父进程恢复执行，子进程开始执行。 `fork()` 系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。
<br/>

通常，创建新的进程都是为了立即执行新的、不同的程序，接着调用 `exec()` 这组函数就可以创建新的地址空间，并把新的程序载入其中。
在现代 Linux 内核中， `fork()` 实际上是由 `clone()` 系统调用完成的，后者将在后面讨论。
<br/>

最终，程序通过 `exit()` 系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过 `wait()` 系统调用查询子进程是否终结，
这其实使得进程拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为僵死状态，直到它的父进程调用 `wait()` 或者 `waitpid()` 为止。

> 注意：进程的另一个名字是 `任务`。Linux 内核通常把进程也叫做任务，两个术语是一样的。

### 进程描述符及任务结构

内核把进程的列表存放在叫做任务队列(task list)的双向循环列表中。链表中的每一项都是类型为 `task_struct`、称为进程描述符的结构，该结构定义在
`<linux/sched.h>` 文件中。进程描述符中包含一个具体进程的所有信息。
<br/>

`task_struct` 相对较大，在 32 位机器上，它大约由 1.7KB。但如果考虑到该结构内包含了内核管理一个进程所需的所有信息，那么它的大小也就算
相当小了。进程描述符中包含的数据能完整描述一个正在执行的程序：它打开的文件、进程的地址空间、挂起的信号、进程的状态、还有其它更多信息。

### 分配进程描述符

Linux 通过 `slab` 分配器分配 `task_struct` 结构，这样能达到对象复用和缓存着色的目的。在 2.6 以前的内核中，各个进程的 `task_struct` 
存放在它们内核栈的尾端。这样做是为了让那些像X86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的为止，从而避免使用额外的寄存器专门记录。
由于现在用 slab 分配器动态生成 `task_struct`，所以只需在栈底(对于向下增长的栈来说)或栈顶(对于向上增长的栈来说)创建一个新的结构 `struct thread_info`
在 x86 上， `struct thread_info`在文件 `<asm/thread_info.h>`中定义如下：
```c
struct thread_info {
    struct task_struct*         task;
    struct exec_domain*         exec_domain;
    __u32                       flags;
    __u32                       status;
    __u32                       cpu;
    int                         preempt_count;
    mm_segment_t                addr_limit;
    struct restart_block        restart_block;
    void*                       sysenter_return;
    int                         uaccess_err;
};
```
<div align=center><img src='/pic/linux/kernel-process-1.png'/></div>
<center>进程描述符和内核栈</center>

> 通过预先分配和重复使用 `task_struct`，可以