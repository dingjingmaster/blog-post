---
title: "Linux内核设计与实现"
date: 2022-09-09T08:47:11+08:00
tags: ['linux', 'kernel', 'kernel-2.6.34']
categories: ['linux']
draft: true
---

> 书中内容基于 `kernel-2.6.34` 版本内核，书籍名《Linux内核设计与实现》

## Linux内核简介

### kernel许可协议

linux kernel 基于 (GPL v2)作为限制条款，保障每个人都可以自由获取、修改内核，但是也要让得到你修改内核的人同时也享有你曾经享有的权利——开源全部源代码。

## 从内核出发

### 内核源码树

|目录|描述|
|:---|:---|
|arch|特定体系结构的源码|
|block|块设备I/O层|
|crypto|加密API|
|Documentation|内核源码文档|
|drivers|设备驱动程序|
|firmware|使用某些驱动程序而需要的设备固件|
|fs|VFS和各种文件系统|
|include|内核头文件|
|init|内核引导和初始化|
|ipc|进程间通信代码|
|kernel|像调度程序这样的核心子系统|
|lib|通用内核函数|
|mm|内存管理子系统和VM|
|net|网络子系统|
|samples|示例代码|
|scripts|编译内核所用的脚本|
|security|Linux安全模块|
|sound|语音子系统|
|usr|早期用户空间代码(所谓的initramfs)|
|tools|在linux开发中有用的工具|
|virt|虚拟化基础结构|

### 配置内核

1. `make config`
2. `make menuconfig`
3. `make gconfig`
4. `make defconfig`：基于默认配置来编译内核
5. `make oldconfig`：基于已有配置来编译内核

### 编译内核
### 安装内核
### 安装内核模块
### 生成initramfs
### 更新引导

> 编译内核时候会在内核代码根目录下创建一个 System.map 文件，这是一份符号对照表，用来将内核符号和他们的起始地址对应起来，调试时候用来把内存地址翻译成容易理解的函数名和变量名。

### 内核开发的特点

- 内核编程时候既不能访问C库，也不能访问标准的C头文件(常用C库函数在linux内核中已经被实现)
- 内核编程时候必须使用 GNU C。
- 内核编程时缺乏用户空间那样的内存保护机制。
- 内核编程时候难以执行浮点运算。
- 内核给每个进程只有一个很小的定长堆栈。
- 由于内核支持异步中断、抢占和SMP，因此必须时刻注意同步和并发。
- 要考虑可移植性

### Kernel头文件使用

- 基本的头文件位于内核源码顶级目录下的`include` 目录中。例如：头文件<linux/inotify.h>对应内核源码树中的`include/linux/inotify.h`
- 体系结构相关的头文件集位于内核源代码树的 `arch/<archiecture>/include/asm`目录下。梅核代码通过以 `asm/`为前缀的方式包含这些头文件，例如：<asm/ioctl.h>

### kernel 打印日志

内核中无`printf()`函数，但是它提供了`printk()`，`printk()`负责把格式化好的字符串拷贝到内核日志缓冲区上，`printf()`和`printk()`之间的一个显著区别在于，`printk()`允许你通过指定一个标志来设置优先级。syslogd会根据这个优先级标志来决定在什么地方显示这条系统信息。
```
printk(KERN_ERR "this is an error\n");
```

### GNU C

Linux内核是用C语言编写的，但是内核不完全符合ANSIC标准，只要有可能，内核开发者总是要用到 gcc 提供的多语言扩展部分(gcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其它代码)。
<br/>

内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性，最早只有 gcc 提供足够多的扩展特性，才可以用来编译linux内核。
<br/>

以下是一些内核代码中使用到的C语言扩展部分：
#### 内联函数(inline)

C99 和 GNU C 都支持内联函数。函数会在调用位置展开，消除函数调用和返回带来的开销(寄存器存储和恢复)。不过也有缺点，这会导致代码变长，意味着占用更多的内存空间或者占用更多的指令缓存。内核开发者通常把那些对事件要求比较高，本身长度又比较短的函数定义成内联函数。如果一个函数较大，会被反复调用，且没有特别的时间上的限制，我们不赞成把它做成内联函数。

定义一个内联函数时候，需要使用`static`作为关键字，并且用`inline`限定它。比如：`static inline void wolf(unsigned long tail_size);`

内核中，为了类型安全和易读性，有限使用内联函数，而不是复杂的宏。

#### 汇编内联

gcc 编译器支持在C函数中嵌入汇编指令。当然在内核编程的时候，只有知道对应的体系结构才能使用这个功能。

通常使用 asm() 指令嵌入汇编代码，例如：
```c
unsigned int low, high; // low 和 high 分别包含64位时间戳的低32位和高32位
asm volatile("rdtsc" : "=a" (low), "=d" (high));
```

Linux 内核混合使用了C语言和汇编语言。在偏近体系结构的底层或对执行事件要求严格的地方，一般使用的是汇编语言。而内核其它部分的大部分代码是用C语言编写的。

#### 分支声明

对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核把这条指令封装成了宏，比如`likely()`和`unlikely()`，这样使用起来比较方便。
<br/>

例如下面是一个条件选择语句：
```c
if (error) {
    /* ... */
}
```
如果想要把这个选择标记成绝少发生的分支：
```c
// 我们认为 error 绝大部分事件都会是0
if (unlikely(error)) {
    /* ... */
}
```

如果想要把一个分支标记位通常为真的选择：
```c 
// 我们认为 success 通常都不会为0
if (likely(success)) {
    /* ... */
}
```
> 在使用这两个宏之前，一定要搞清楚这个条件，如果判断不准确，那么性能反而会下降。

#### 没有内存保护机制

如果用户程序访问非法内存，内核会发现这个错误，发送 SIGSEGV 信号，并结束整个进程。

如果内核自己非法访问内存，就会导致 oops，且结果很难控制。

另外内核中的内存并不分页，也就是说，你每用掉一个字节，物理内存就减少一个字节。所以，在你想往内核里加入新功能时候要记住这一点。

#### 不要轻易在内核中使用浮点数

在用户空间的进程内使用浮点操作的时候，内核会完成从整数操作模式到浮点数操作模式转换。在执行浮点指令时候因体系结构不同，内核的选择也不同，但是，内核通常捕获陷阱并着手于整数到浮点方式的转变。

与用户空间进程不同，内核并不能完美地支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时候，除了要人工保存和恢复浮点寄存器，还有其它一些琐碎的事情要做。如果要直截了当的回答，那就是：别这样做，除非一些极少情况，否则别在内核中使用浮点操作。

#### 容积小而固定的栈

用户空间的程序可以从栈上分配大量的空间来存放变量，甚至巨大的结构体或者是包含数以千计的数据项的数组都没问题。之所以可以这么做，是因为用户空间的栈本身比较打，而且还能动态增长。

内核堆栈的准确大小随体系结构而变。在 X86 上，栈的大小在编译时候配置，可以是 4KB 也可以是 8KB。

历史上说，内核栈的大小是两页，32位机器内核栈是 8KB，而 64位机器是 16KB，这个固定不变的，每个处理器都有自己的栈。

#### 同步和并发

内核很容易产生竞争条件。和单线程的用户空间程序不同，内核的许多特性都要求能够并发地访问共享数据，这就要求有同步机制以保证不出现竞争条件，特别是：

- Linux是抢占多任务操作系统。内核的进程调度程序即兴对进程进行调度和重新调度。内核必须和这些任务同步。
- Linux内核支持对称多处理器系统(SMP)。所以，如果没有适当的保护，同时在两个或两个以上的处理器上执行的内核代码很可能会同时访问共享的同一个资源。
- 中断是异步到来的，完全不顾及当前正在执行的代码。也就是说，如果不加以适当的保护，中断完全有可能在代码访问资源的时候到来，这样，中断处理程序就有可能访问同一资源。
- Linux内核可以抢占。所以，如果不加以适当的保护，内核中一段正在执行的代码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资源。

常用的解决竞争的办法是`自旋锁`和`信号量`。

#### 可移植性的重要性

大部分 C 代码应该与体系结构无关，在许多不同体系结构的计算机上都能编译和执行，因此，必须把与体系结构相关的代码从内核代码树的特定目录中适当地分离出来。

诸如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。

## 进程管理

- 进程定义和相关概念，比如：线程
- Linux内核如何管理进程
- 进程在内核中的生命周期

**进程管理是整个操作系统的心脏所在**

### 进程

进程是处于执行期的程序(目标码存放在某种介质上)。但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，text section)。通常进程还要包含其它资源，
像打开的文件、挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，当然还包括用来存放全局变量的数据段等。
实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明的管理所有细节。

执行线程，简称线程，是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。
在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包含多个线程的多线程程序司空见惯。对Linux而言，并不特别区分线程和进程。
<br/>

在现代操作系统中，进程提供两种虚拟机制：**虚拟处理器**和**虚拟内存**。虽然实际上可能是许多进程正在分享一个处理器，但是虚拟处理器给进程一个假象，
让这些进程觉得自己在独享处理器。
<br/>

程序不是进程，进程是处于执行期间程序及其相关资源的总称。
<br/>

Linux通过调用 `fork()` 复制一个现有进程来创建一个全新的进程。调用 `fork()` 的进程称为父进程，新产生的进程称为 `子进程`。在调用结束时候，
在返回点这个相同位置上，父进程恢复执行，子进程开始执行。 `fork()` 系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。
<br/>

通常，创建新的进程都是为了立即执行新的、不同的程序，接着调用 `exec()` 这组函数就可以创建新的地址空间，并把新的程序载入其中。
在现代 Linux 内核中， `fork()` 实际上是由 `clone()` 系统调用完成的，后者将在后面讨论。
<br/>

最终，程序通过 `exit()` 系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过 `wait()` 系统调用查询子进程是否终结，
这其实使得进程拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为僵死状态，直到它的父进程调用 `wait()` 或者 `waitpid()` 为止。

> 注意：进程的另一个名字是 `任务`。Linux 内核通常把进程也叫做任务，两个术语是一样的。

### 进程描述符及任务结构

内核把进程的列表存放在叫做任务队列(task list)的双向循环列表中。链表中的每一项都是类型为 `task_struct`、称为进程描述符的结构，该结构定义在
`<linux/sched.h>` 文件中。进程描述符中包含一个具体进程的所有信息。
<br/>

`task_struct` 相对较大，在 32 位机器上，它大约有 1.7KB。但如果考虑到该结构内包含了内核管理一个进程所需的所有信息，那么它的大小也就算
相当小了。进程描述符中包含的数据能完整描述一个正在执行的程序：此进程打开的文件、进程的地址空间、挂起的信号、进程的状态、还有其它更多信息。

#### 分配进程描述符

Linux 通过 `slab` 分配器分配 `task_struct` 结构，这样能达到对象复用和缓存着色的目的。在 2.6 以前的内核中，各个进程的 `task_struct` 
存放在它们内核栈的尾端。这样做是为了让那些像X86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，从而避免使用额外的寄存器专门记录。
由于现在用 slab 分配器动态生成 `task_struct`，所以只需在栈底(对于向下增长的栈来说)或栈顶(对于向上增长的栈来说)创建一个新的结构 `struct thread_info`
在 x86 上， `struct thread_info`在文件 `<asm/thread_info.h>`中定义如下：
```c
struct thread_info {
    struct task_struct*         task;
    struct exec_domain*         exec_domain;
    __u32                       flags;
    __u32                       status;
    __u32                       cpu;
    int                         preempt_count;
    mm_segment_t                addr_limit;
    struct restart_block        restart_block;
    void*                       sysenter_return;
    int                         uaccess_err;
};
```
<div align=center><img src='/pic/linux/kernel-process-1.png'/></div>
<center>进程描述符和内核栈</center>

每个任务的 `thread_info` 结构在它的内核栈的末尾端分配。结构中 task 域中存放的是指向该任务实际 `task_struct` 的指针。

> 通过预先分配和重复使用 `task_struct`，可以避免动态分配和释放带来的资源消耗。

>寄存器较弱的体系结构不是引入 `thread_info` 结构的唯一原因。这个新建的结构使在汇编代码中计算其偏移变得非常容易。

#### 进程描述符的存放

内核通过一个唯一的进程标识值(process identification value) 或 PID 来标识每个进程。PID 是一个数，标识为 pid_t 隐含类型(隐含类型标识隐藏了该类型实现，用句柄替代类型实现)，
实际上就是一个int类型。为了与老版本的Unix和Linux兼容，PID 的最大值默认设置为 32768 (short int 短整型的最大值)，当然这个值也可以增加到
400万(受 `<linux/threads.h>` 中所定义PID最大值的限制)。

内核把每个进程 PID 存放在它们各自的进程描述符中。

> PID 最大值表明了系统中允许同时存在的进程的最大数目。32768一般来说够用了，而且这个值越小，进程调度一圈就越快。

在内核中，访问任务/进程通常需要获得指向其 `task_struct` 的指针。实际上，内核中大部分处理进程的代码都是直接通过
`task_struct` 进行的。因此，通过 `current` 宏查找到当前正在运行进程的进程描述符的速度就显得尤为重要。硬件体系结构不同，
该宏的实现也不同，它必须针对专门的硬件体系结构做处理。有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程
`task_struct` 的指针，用于加快访问速度。而有些像x86这样的体系结构(其寄存器并不富余)，就只能在内核栈的尾端创建 
`thread_info` 结构，通过计算偏移间接地查找 `task_struct` 结构。

在 X86 系统上，current 把栈指针的后 13 个有效位屏蔽掉，用来计算出 `thread_info` 的偏移。该操作是通过 `current_thread_info()`
函数完成的。汇编代码如下：
```asm
mov1 $-8192, %eax
andl %esp, %eax
```
> 这里假定栈的大小为 8KB。当 4KB 的栈启用时候，就要用 4096，而不是 8192.

最后，current再从 `thread_info` 的 `task` 域中提取并返回 `task_struct` 的地址：
```c
current_thread_info()->task;
```

> 对比一下这部分在 PowerPC (IBM基于RISC 的现代微处理器)，我呢把可以发现 PPC 当前的 `task_struct` 是保存在一个寄存器中。
> 也就是说，在 PPC 上， current 宏只需要把 r2 寄存器中的值返回就行了。与 X86 不一样，PPC 有足够多的寄存器，所以它的实现有这样选择的余地。
> 而访问进程描述符是一个重要的频繁操作，所以 PPC 的内核开发者觉得完全有必要为此使用一个专门的寄存器。

#### 进程状态

进程描述符中的 `state` 域描述了进程的当前状态。系统中的每个进程都必然处于五种进程状态中的一种。该域的值也必为以下五种状态标识之一：

- TASK_RUNNING(运行) —— 进程是可执行的：它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态；这种状态也可以应用到内核空间中正在执行的进程。
- TASK_INTERRUPTIBLE(可中断) —— 进程正在睡眠(也就是说它被阻塞)，等待某些条件的达成。一旦这些条件达成，内核就会把
进程状态设置为可运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。
- TASK_UNINTERRUPTIBLE(不可中断) —— 除了就算是接收到信号也不会被唤醒或者准备投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须等待时不受干扰或等待事件很快就会发生时候出现。由于处于此状态的任务对信号不做响应，所以较之可中断状态使用的比较少。
- __TASK_TRACED —— 被其它进程跟踪的进程，例如通过 `ptrace` 对调试程序进行跟踪。
- __TASK_STOPPED(停止) —— 进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到 `SIGSTOP`、`SIGTSTP`、`SIGTTOU` 等信号的时候，此外在调试期间收到任何信号，都会使进程进入这种状态。

<div align=center><img src='/pic/linux/kernel-process-2.png'/></div>
<center>进程状态转化</center>

#### 设置当前进程状态

内核经常需要调整某个进程的状态。这时最好使用 `set_task_state(task, state)` 函数：
```c
set_task_state(task, state);    // 将任务 task 的状态设置为 state
```

该函数将指定的进程设置为指定状态。必要的时候下，它会设置内存屏障来强制其它处理器做重新排序(一般只有在 SMP 系统中有此必要)。否则，它等价于：
```c
task->state = state;
```

> set_current_state(state) 和 set_task_state(current, state) 含义是等同的。参看 `<linux/sched.h>` 中相关函数的说明。

#### 进程上下文

可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。
此时，我们称内核 “代表进程执行”并处于进程上下文中。在此上下文中 `current` 宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。

系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行 —— 对内核的所有访问都必须通过这些接口。

#### 进程家族树

Unix 系统的进程之间存在一个明显的继承关系，在linux系统中也是如此。所有的进程都是 PID 为 1 的 init 进程的后代。
内核在系统启动的最后阶段启动 init 进程。该进程读取系统的初始化脚本(initscript) 并执行其它的相关程序，最终完成系统启动的整个过程。

系统中的每个进程必有一个父进程，每个进程也可以拥有零个或多个子进程。拥有同一个父进程的所有进程都被称为**兄弟**。进程的关系存放在进程描述符中。每个 
`task_struct` 都包含一个指向其父进程的 `task_struct`、叫做 `parent` 的指针，还包含一个称为 `children` 的子进程链表。所以，对于
当前进程，可以通过下面的代码获得其父进程的进程描述符：
```c
struct task_struct*         myParent = current->parent;
```
同样，也可以按以下方式依次访问子进程：
```c
struct task_struct* task;
struct list_head* list;

list_for_each(list, &current->children) {
    task = list_entry(list, struct task_struct, sibling);
    /* task 现在指向当前的某个子进程 */
}
```
init 进程的描述符是作为 `init_task` 静态分配的。下面的代码可以很好的演示所有进程之间的关系：

```c
struct task_struct* task;
for (task = current; task != &init_task; task = task->parent) {
    // task 现在指向 init
}
```

实际上，你可以通过这种继承体系从系统的任何一个进程出发查找到任意指定的其它进程。但大多数时候，只需要通过简单的重复的方式就
可以遍历系统中的所有进程。这非常容易做到，因为一个任务队列本来就是一个双向的循环链表。对于给定的进程，获取链表中的下一个进程：
```c
list_entry(task->tasks.next, struct task_struct, tasks)
```
获取前一个进程的方法与之相同：
```c
list_entry(task->tasks.prev, struct tsak_struct, tasks)
```
这两个例程分别通过`next_task(task)`宏和`prev_task(task)`宏实现。而实际上，`for_each_process(task)`宏提供了依次访问整个任务队列的能力。
每次访问，任务指针都指向链表中的下一个元素：
```c
struct task_struct* task;

for_each_process(task) {
    // 它打印出每一个任务的名称和PID
    printk("%s [%d]\n", task->comm, task->pid);
}
```
> 在一个拥有大量进程的系统中通过重复来遍历所有进程的代价是很大的。因此，如果没有必须这样做的理由，不要这样做。

### 进程创建

Unix 的进程创建很特别。许多其它的操作系统都提供了产生(spawn)进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。

Unix采用了与众不同的实现方式，它把上述步骤分解到两个单独的函数中去执行： `fork()` 和 `exec()`。

首先， `fork()` 通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于 PID(每个进程唯一)、PPID(父进程的进程号，子进程将其设置为被拷贝进程的PID)
和某些资源和统计量(例如，挂起的信号，它没有必要被继承)。

`exec()`函数负责读取可执行文件并将其载入地址空间开始运行。把这两个函数组合起来使用的效果跟其它系统使用的单一函数的效果相似。

#### 写时拷贝

传统的 `fork()` 系统调用直接把所有资源复制给新创建的进程。这种实现过于简单且效率低下，因为它拷贝的数据也许并不共享，更糟糕的是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。
Linux 的 `fork()` 十一鸥鸟更写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。

只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候才进行。
在页根本不会被写入的情况下(距离来说，`fork()`后立即调用`exec()`)他们就无需复制了。

`fork()`的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。在一般情况下，进程创建后会马上运行一个可执行文件，这种优化可以避免拷贝大量根本都不会被使用的数据(地址空间里常常包含数十兆的数据)。
由于Unix强调进程快速执行的能力，所以这个优化是很重要的。

#### `fork()`

Linux 通过 clone() 系统调用实现 `fork()`。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。
`fork()`、`vfork()`和`__clone()`库函数都根据各自需要的参数标志去调用 `clone()`，然后由 `clone()` 去调用 `do_fork()`。

`do_fork()`完成创建中的大部分工作(定义在 `kernel/fork.c` 中)，该函数调用 `copy_process()` 函数，然后让进程开始运行。 `copy_process()`完成以下主要工作：
1. 调用 `dup_task_struct()` 为新进程创建一个内核栈、`thread_info` 结构和 `task_struct`，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。
2. 检查并确保新创建这个子进程后，当前用户拥有的进程数目没有超出给它分配的资源的限制。
3. 子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清零或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息。task_struct中的大多数数据都依然未被修改。
4. 子进程的状态被设置为 `TASK_UNINTERRUPTIBLE`，以保证它不会投入运行。
5. `copy_process()`调用 `copy_flags()` 以更新 `task_struct` 的 flags 成员。表明进程是否拥有超级用户权限的
`PF_SUPERPRIV`标志被清零。表明进程还没有调用 `exec()` 函数的 `PF_FORKNOEXEC` 标志被设置。
6. 调用 `alloc_pid()` 为新进程分配一个有效的 PID。
7. 根据传递给 `clone()` 的参数标志，`copy_process()`拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。
在一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝在这里。
8. 最后，`copy_process()`做收尾工作并返回一个指向子进程的指针。

再回到 `do_fork()`函数，如果 `copy_process()` 函数返回成功，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用 `exec()`函数，这样可以避免写时拷贝的额外开销，如果父进程首先
执行的话，有可能会开始向地址空间写入。

#### `vfork()`

除了不拷贝父进程的页表项外，`vfork()`系统调用和`fork()`的功能相同。子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行
`exec()`。子进程不能向地址空间写入。在过去的 3BSD 时期，这个优化是有意义的，那时并未使用写时拷贝页来实现
`fork()`。现在由于在执行`fork()`十引入了写时拷贝页而且明确了子进程先执行，`vfork()`的好处就仅限于不拷贝父进程的页表项了。
如果 Linux 将来`fork()`有了写时拷贝页表项，那么`vfork()`就彻底没用了。另外由于`vfork()`语义非常微妙(试想，如果`exec()`调用失败会发生什么)，
所以理想情况下，系统最后不要调用 `vfork()`，内核也不用实现它。完全可以把 `vfork()` 实现成一个普普通通的 `fork()` —— 实际上，Linux2.2以前就是这么做的。
<br/>

`vfork()`系统调用的实现是通过向 `clone()` 系统调用传递一个特殊标志来进行的。
1. 在调用 `copy_process()` 时候，`task_struct` 的 `vfork_done`成员被设置为 `NULL`。
2. 在执行 `do_fork()` 时，如果给定特别标志，则 `vfork_done`会指向一个特定地址。
3. 子进程先开始执行后，父进程不是马上恢复执行，而是一直等待，直到子进程通过`vfork_done`指针向他发送信号。
4. 在调用 mm_release() 时候，该函数用于进程退出内存地址空间，并且检查 `vfork_done` 是否为空，如果不为空，则会向父进程发送信号。
5. 回到 `do_fork()`，父进程醒来并返回。
如果一切执行顺利，子进程在新的地址空间里运行而父进程也恢复了在原地址空间的运行。这样，开销确实降低了，不过它的实现并不是优良的。

### 线程在Linux中的实现

线程机制是现代编程技术中非常常用的一种抽象概念。该机制提供了在同一个程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其它资源线程机制支持并发程序设计技术，在多处理器系统上，它也能保证真正的并行处理。

Linux 实现线程的机制非常独特。从内核角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或者定义特别的数据结构来表征线程。
相反，线程仅仅被视为一个与其它进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的 `task_struct`，素以在内核中，它看起来就像是一个普通的进程
(只是线程和其它一些进程共享某些资源，如地址空间)。

上述线程机制的实现与`Windows` 或是 `Sun Solaris` 等操作系统的实现差异非常大。这些系统都在内核中提供了专门支持线程的机制(这写系统常常把线程称作轻量级进程)。
“轻量级进程”这种叫法本身就概括了Linux在此处与其它系统的差异。

在其它系统中，相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于linux来说，它只是一种进程间共享资源的手段(Linux进程本身就够轻量级的来)。
举个例子来说，假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有一个包含指向四个不同线程的指针的进程描述符。
该描述符负责描述像地址空间、打开的文件这样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅创建四个进程并分配四个普通的
`task_struct`结构。建立这四个进程时候指定他们共享某些资源，这是相当高雅的做法。

#### 创建线程

线程的创建和普通进程的创建类似，只不过在调用 `clone()` 的时候需要传递一些参数标志来指明需要共享的资源：
```c
clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND, 0);
```
上面的代码产生的结果和调用`fork()`差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。换个说法就是，新建的进程和它的父进程就是流行的所谓线程。

对比以下，一个普通的 `fork()` 的实现是：
```c
clone(CLONE_VFORK|CLONE_VM|SIGCHLE, 0);
```

传递给 `clone()` 的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。
表3-1列举了这些`clone()`用到的参数标志以及他们的作用，这些是在`<linux/sched.h>`中定义的。

|参数标志|含义|
|:---|:---|
|CLONE_FILES|父子进程共享打开的文件|
|CLONE_FS|父子进程共享文件系统信息|
|CLONE_IDLETASK|将PID设置为0(只供idle进程使用)|
|CLONE_NEWNS|为子进程创建新的命名空间|
|CLONE_PARENT|指定子进程与父进程拥有同一个父进程|
|CLONE_PTRACE|继续调试子进程|
|CLONE_SETTID|将 TID 回写至用户空间|
|CLONE_SETTLS|为子进程创建新的 TLS(thread-local storage)|
|CLONE_SIGHAND|为父进程共享信号处理函数及被阻断的信号|
|CLONE_SYSVSEM|父子进程共享 System V SEM_UNDO 语义|
|CLONE_THREAD|父子进程放入相同的线程组|
|CLONE_VFORK|调用`vfork()`，所以父进程准备睡眠等待子进程将其唤醒|
|CLONE_UNTRACED|防止跟踪进程在子进程上强制执行 `CLONE_PTRACE`|
|CLONE_STOP|以TASK_STOPPED状态开始进程|
|CLONE_CHILD_CLEARTID|清除子进程的TID|
|CLONE_CHILD_SETTID|设置子进程的TID|
|CLONE_PARENT_SETTID|设置父进程的TID|
|CLONE_VM|父子进程共享地址空间|

#### 内核线程

内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成 —— 独立运行在内核空间的标准进程。
<br/>

内核线程与普通进程间的区别在于内核线程没有独立的地址空间(实际上指向地址空间的mm指针被设置为NULL)。
它们只在内核空间运行，从来不切换到用户空间去，内核进程和普通进程一样，可以被调度，也可以被抢占。

> Linux确实会把一些任务交给内核线程去做，像`flush`和`ksofirqd`这些任务就是明显的例子。

内核线程是在系统启动时候由其它内核线程创建。内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在
`<linux/kthread.h>`中声明有接口，于是，从现有内核线程中创建一个新的内核线程的方法如下：
```c
struct task_struct* kthread_create (int (*threadfn) (void* data), void* data, const char namefmt[], ...)
```
新的任务是由 kthread 内核进程通过 `clone()`系统调用而创建的。新的进程将运行 `threadfn` 函数，给其传递的参数是data。
进程会被命名为 namefmt, namefmt接受可变参数列表类似于 `printf()` 的格式化参数。新创建的进程处于不可运行状态，如果不通过调用 
`wake_up_process()`明确地唤醒它，它不会主动运行。创建一个进程并让它运行起来，可以通过调用 `kthread_run()`来达到：
```c
struct task_struct* kthread_run (int (*threadfn) (void* data), void* data, const char namefmt[], ...)
```
这个例程是以宏实现的，只是简单地调用了 `kthread_create()` 和 `wake_up_process()`：
```c
#define kthread_run(threadfn, data, namefmt, ...)               \
({                                                              \
    struct task_struct* k;                                      \
    k = kthread_create(threadfn,data,namefmt,## __VA_ARGS__);   \
    if (!IS_ERR(k))                                             \
        wake_up_process(k);                                     \
    k;                                                          \
})
```
内核线程启动后就一直运行直到调用 `do_exit()` 退出，或者内核的其它部分调用 `kthread_stop()`退出，传递给
`kthread_stop()`的参数为`kthread_create()`函数返回的 `task_struct`结构的地址：
```c
int kthread_stop(struct task_struct* k);
```

### 进程终结

进程终结时候，内核必须释放它所占有的资源，并把这一消息告知父进程。

一般来说，进程的析构是自身引起的。它发生在进程调用`exit()`系统调用时候，既可能显示地调用这个系统调用，也可能显示地从某个程序的主函数返回
(其实C语言编译器会在main()函数的返回点后面放置调用`exit()`的代码)。当进程接受到它既不能处理也不能忽略的信号或异常时候，它还可能主动被终结。不管进程是怎么终结的，该任务
大部分要靠`do_exit()`(定义于kernel/exit.c)来完成，它要做下面这些繁琐工作：
1. 将 `task_struct` 中的标志成员设置为 `PF_EXITING`
2. 调用 `del_timer_sync()` 删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。
3. 如果 BSD 的进程记账功能是开启的，`do_exit()` 调用 `acct_update_integrals()` 来输出记账信息。
4. 然后调用 `exit_mm()`函数释放进程占用的 `mm_struct`，如果没有别的进程使用它们(也就是说，这些地址空间没有被共享)，就彻底释放它们。
5. 接下来调用 `sem_exit()` 函数。如果进程排队等候 IPC 信号，它则离开队列。
6. 调用 `exit_files()` 和 `exit_fs()`，以分别递减文件描述符、文件系统数据的引用计数。如果某个引用计数值为0，那么就代表没有进程在使用相应的资源，此时可以释放。
7. 接着把存放在 `task_struct` 的 `exit_code` 成员中的任务退出代码置为由 `exit()` 提供的退出代码，或者去完成任何其它由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。
8. 调用 `exit_notify()` 向父进程发送信号，给子进程重新找养父，养父为线程组中的其它线程或者为 `init` 进程，并把进程状态(存放在`task_struct`结构的
`exit_state`中)设成 `EXIT_ZOMBIE`。
9. `do_exit()`调用 `schedule()` 切换到新的进程。因为处于 `EXIT_ZOMBIE` 状态的进程不会再被调度，所以这时进程所执行的最后一段代码。`do_exit()` 永不返回。

至此，与进程相关联的所有资源都被释放掉了(假设该进程是这些资源的唯一使用者)。进程不可运行(实际上也没有地址空间让他运行)并处于`EXIT_ZOMBIE`
退出状态。它占用的所有内存就是内核栈、thread_info结构和task_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内存被释放，归还给系统使用。

#### 删除进程描述符

在调用了 `do_exit()` 之后，尽管线程已经僵死不能再运行了，但是系统还是保留了它的进程描述符。前面说过，这样做可以让系统有办法在子进程终结后仍然获得它的信息。因此，进程终结时候所需的清理工作和进程描述符的删除被分开执行。
在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的`task_struct`结构才被释放。
<br/>

`wait()`这一族函数都是通过唯一(但是很复杂)的一个系统调用 `wait4()`来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。
此外，调用该函数时候提供的指针会包含子函数退出时候的退出码。
<br/>

当最终需要释放进程描述符时候，`release_task()`会被调用，用以完成以下工作：
1. 它调用 `__exit_signal()`，该函数调用`__unhash_process()`，后者又调用 `detach_pid()` 从 `pidhash` 上删除该进程，同时也要从任务列表中删除该进程。
2. `_exit_signal()`释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。
3. 如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么 `release_task()` 就要通知僵死的领头进程的父进程。
4. `release_task()` 调用`put_task_struct()`释放进程内核栈和`thread_info`结构所占的页，并释放`task_struct`所占的 slab 高速缓存。

至此，进程描述符和所有进程独享的资源全部被释放掉。

#### 孤儿进程造成的进退维谷

如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时候永远处于僵死状态，白白地耗费内存。
前面的部分已经有所暗示，对于这个问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让 init 做它们的父进程。在 `do_exit()`
中会调用 `exit_notify()`，该函数会调用 `forget_original_parent()`，而后者会调用 `find_new_reaper()` 来执行寻父过程：
```c
static struct task_struct* find_new_reaper (struct task_struct* father)
{
    struct pid_namespace* pid_ns = task_active_pid_ns (father);
    struct task_struct* thread;
    
    thread = father;
    while_each_thread(father, thread) {
        if (thread->flags & PF_EXITING)
            continue;
        if (unlikely(pid_ns->child_reaper == father))
            pid_ns->child_reaper = thread;
        return thread;
    }
    
    if (unlikely (pid_ns->child_reaper == father)) {
        write_unlock_irq (&tasklist_lock);
        if (unlikely(pid_ns == &init_pid_ns))
            panic ("Attempted to kill init!");
        zap_pid_ns_processes (pid_ns);
        write_lock_irq(&tasklist_lock);
        
        pid_ns->child_reaper = init_pid_ns.child_reaper;
    }
    return pid_ns->child_reaper;
}
```

这段代码试图找到进程所在线程组内的其它进程。如果线程组内没有其它进程，他就找到并返回的是 init 进程。现在，给子进程找到合适的养父进程来，
只需遍历所有子进程并为它们设置新的父进程：
```c
reaper = find_new_reaper(father);
list_for_each_entry_safe(p, n, &father->children, sibling) {
    p->real_parent = reaper;
    if (p->parent == father) {
        BUG_ON(p->ptrace);
        p->parent = p->real_parent;
    }
    reparent_thread(p, father);
}
```
然后调用 `ptrace_exit_finish()` 同样进行新的寻父过程，不过这次是给 `ptraced` 的子进程寻找父亲。
```c
void exit_ptrace(struct task_struct* tracer)
{
    struct task_struct *p, *n;
    LIST_HEAD(ptrace_dead);
    
    write_lock_irq(&tasklist_lock);
    list_for_each_entry_safe(p, n, &tracer->ptraced, ptrace_entry) {
        if (__ptrace_detach(tracer, p)) {
            list_add (&p->ptrace_entry, &ptrace_dead);
        }
    }

    write_unlock_irq(&tasklist_lock);
    BUG_ON(!list_empty(&tracer->ptraced));

    list_for_each_entry_safe(p, n, &ptrace_dead, ptrace_entry) {
        list_del_init(&p->ptrace_entry);
        release_task(p);
    }
}
```
这段代码遍历了两个链表：子进程链表和`ptrace`子进程链表，给每个子进程设置新的父进程。这两个链表同时存在的原因很有意思，它也是2.6内核的一个新特性。
当一个进程被跟踪时，它的临时父亲设定为调试进程。此时如果它的父进程退出了，系统会为它和它的所有兄弟重新找一个父进程。在以前的内核中，这就需要遍历系统所有
的进程来找这些子进程。现在的解决方法是在一个单独的被`ptrace`跟踪的子进程链表中搜索相关的兄弟进程 —— 用两个相对较小的链表减轻了遍历带来的消耗。
<br/>

一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。`init`进程会例行调用`wait()`来检查其子进程，清除所有与其相关的僵死进程。




















